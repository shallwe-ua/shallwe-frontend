=================
PROJECT STRUCTURE:
=================

shallwe-frontend/
|-- shallwe_frontend
|   |-- public
|   |   |-- img
|   |   |   `-- profile
|   |   |       `-- test-default192.webp
|   |   `-- mockServiceWorker.js
|   |-- src
|   |   |-- app
|   |   |   |-- components
|   |   |   |   |-- layout
|   |   |   |   |   |-- Footer.tsx
|   |   |   |   |   `-- Header.tsx
|   |   |   |   |-- mock
|   |   |   |   |   `-- MSWInit.tsx
|   |   |   |   `-- profile
|   |   |   |       |-- BirthDateSelect.tsx
|   |   |   |       |-- Locations.tsx
|   |   |   |       |-- PhotoWithFallbacks.tsx
|   |   |   |       |-- ProfileEditView.tsx
|   |   |   |       `-- ProfilePhotoPick.tsx
|   |   |   |-- settings
|   |   |   |   `-- page.tsx
|   |   |   |-- setup
|   |   |   |   `-- page.tsx
|   |   |   |-- globals.css
|   |   |   |-- layout.tsx
|   |   |   `-- page.tsx
|   |   |-- config
|   |   |   `-- env.ts
|   |   |-- lib
|   |   |   |-- common
|   |   |   |   `-- cookie.ts
|   |   |   `-- shallwe
|   |   |       |-- access
|   |   |       |   `-- api
|   |   |       |       |-- calls.ts
|   |   |       |       `-- schema.ts
|   |   |       |-- auth
|   |   |       |   `-- api
|   |   |       |       `-- calls.ts
|   |   |       |-- common
|   |   |       |   `-- api
|   |   |       |       |-- calls.ts
|   |   |       |       |-- schema.ts
|   |   |       |       `-- typeGuards.ts
|   |   |       |-- locations
|   |   |       |   `-- api
|   |   |       |       |-- calls.ts
|   |   |       |       `-- schema.ts
|   |   |       |-- photo
|   |   |       |   |-- api
|   |   |       |   |   `-- calls.ts
|   |   |       |   `-- formstates
|   |   |       |       `-- validators.ts
|   |   |       `-- profile
|   |   |           |-- api
|   |   |           |   |-- schema
|   |   |           |   |   |-- common.ts
|   |   |           |   |   |-- create.ts
|   |   |           |   |   |-- read.ts
|   |   |           |   |   `-- update.ts
|   |   |           |   |-- calls.ts
|   |   |           |   `-- multipart.ts
|   |   |           `-- formstates
|   |   |               |-- collectors
|   |   |               |   |-- create.ts
|   |   |               |   `-- update.ts
|   |   |               |-- validators
|   |   |               |   |-- common.ts
|   |   |               |   |-- create.ts
|   |   |               |   `-- update.ts
|   |   |               `-- states.ts
|   |   |-- mocks
|   |   |   |-- browser.ts
|   |   |   `-- handlers.ts
|   |   `-- middleware.ts
|   |-- .gitignore
|   |-- eslint.config.mjs
|   |-- next.config.ts
|   |-- package.json
|   |-- postcss.config.mjs
|   |-- tailwind.config.ts
|   `-- tsconfig.json
|-- tools
|   `-- compose_project_snapshot.cjs
|-- .env.example
|-- .gitignore
|-- LICENSE
|-- project_snapshot.txt
`-- README.md

=================
CODE/TEXT CONTENT OF THE PROJECT
=================

shallwe_frontend/public/img/profile/test-default192.webp:

[skipped: .webp file (extension-based skip)]
_____________________________

shallwe_frontend/public/mockServiceWorker.js:

/* eslint-disable */
/* tslint:disable */

/**
 * Mock Service Worker.
 * @see https://github.com/mswjs/msw
 * - Please do NOT modify this file.
 */

const PACKAGE_VERSION = '2.11.3'
const INTEGRITY_CHECKSUM = '4db4a41e972cec1b64cc569c66952d82'
const IS_MOCKED_RESPONSE = Symbol('isMockedResponse')
const activeClientIds = new Set()

addEventListener('install', function () {
  self.skipWaiting()
})

addEventListener('activate', function (event) {
  event.waitUntil(self.clients.claim())
})

addEventListener('message', async function (event) {
  const clientId = Reflect.get(event.source || {}, 'id')

  if (!clientId || !self.clients) {
    return
  }

  const client = await self.clients.get(clientId)

  if (!client) {
    return
  }

  const allClients = await self.clients.matchAll({
    type: 'window',
  })

  switch (event.data) {
    case 'KEEPALIVE_REQUEST': {
      sendToClient(client, {
        type: 'KEEPALIVE_RESPONSE',
      })
      break
    }

    case 'INTEGRITY_CHECK_REQUEST': {
      sendToClient(client, {
        type: 'INTEGRITY_CHECK_RESPONSE',
        payload: {
          packageVersion: PACKAGE_VERSION,
          checksum: INTEGRITY_CHECKSUM,
        },
      })
      break
    }

    case 'MOCK_ACTIVATE': {
      activeClientIds.add(clientId)

      sendToClient(client, {
        type: 'MOCKING_ENABLED',
        payload: {
          client: {
            id: client.id,
            frameType: client.frameType,
          },
        },
      })
      break
    }

    case 'CLIENT_CLOSED': {
      activeClientIds.delete(clientId)

      const remainingClients = allClients.filter((client) => {
        return client.id !== clientId
      })

      // Unregister itself when there are no more clients
      if (remainingClients.length === 0) {
        self.registration.unregister()
      }

      break
    }
  }
})

addEventListener('fetch', function (event) {
  const requestInterceptedAt = Date.now()

  // Bypass navigation requests.
  if (event.request.mode === 'navigate') {
    return
  }

  // Opening the DevTools triggers the "only-if-cached" request
  // that cannot be handled by the worker. Bypass such requests.
  if (
    event.request.cache === 'only-if-cached' &&
    event.request.mode !== 'same-origin'
  ) {
    return
  }

  // Bypass all requests when there are no active clients.
  // Prevents the self-unregistered worked from handling requests
  // after it's been terminated (still remains active until the next reload).
  if (activeClientIds.size === 0) {
    return
  }

  const requestId = crypto.randomUUID()
  event.respondWith(handleRequest(event, requestId, requestInterceptedAt))
})

/**
 * @param {FetchEvent} event
 * @param {string} requestId
 * @param {number} requestInterceptedAt
 */
async function handleRequest(event, requestId, requestInterceptedAt) {
  const client = await resolveMainClient(event)
  const requestCloneForEvents = event.request.clone()
  const response = await getResponse(
    event,
    client,
    requestId,
    requestInterceptedAt,
  )

  // Send back the response clone for the "response:*" life-cycle events.
  // Ensure MSW is active and ready to handle the message, otherwise
  // this message will pend indefinitely.
  if (client && activeClientIds.has(client.id)) {
    const serializedRequest = await serializeRequest(requestCloneForEvents)

    // Clone the response so both the client and the library could consume it.
    const responseClone = response.clone()

    sendToClient(
      client,
      {
        type: 'RESPONSE',
        payload: {
          isMockedResponse: IS_MOCKED_RESPONSE in response,
          request: {
            id: requestId,
            ...serializedRequest,
          },
          response: {
            type: responseClone.type,
            status: responseClone.status,
            statusText: responseClone.statusText,
            headers: Object.fromEntries(responseClone.headers.entries()),
            body: responseClone.body,
          },
        },
      },
      responseClone.body ? [serializedRequest.body, responseClone.body] : [],
    )
  }

  return response
}

/**
 * Resolve the main client for the given event.
 * Client that issues a request doesn't necessarily equal the client
 * that registered the worker. It's with the latter the worker should
 * communicate with during the response resolving phase.
 * @param {FetchEvent} event
 * @returns {Promise<Client | undefined>}
 */
async function resolveMainClient(event) {
  const client = await self.clients.get(event.clientId)

  if (activeClientIds.has(event.clientId)) {
    return client
  }

  if (client?.frameType === 'top-level') {
    return client
  }

  const allClients = await self.clients.matchAll({
    type: 'window',
  })

  return allClients
    .filter((client) => {
      // Get only those clients that are currently visible.
      return client.visibilityState === 'visible'
    })
    .find((client) => {
      // Find the client ID that's recorded in the
      // set of clients that have registered the worker.
      return activeClientIds.has(client.id)
    })
}

/**
 * @param {FetchEvent} event
 * @param {Client | undefined} client
 * @param {string} requestId
 * @returns {Promise<Response>}
 */
async function getResponse(event, client, requestId, requestInterceptedAt) {
  // Clone the request because it might've been already used
  // (i.e. its body has been read and sent to the client).
  const requestClone = event.request.clone()

  function passthrough() {
    // Cast the request headers to a new Headers instance
    // so the headers can be manipulated with.
    const headers = new Headers(requestClone.headers)

    // Remove the "accept" header value that marked this request as passthrough.
    // This prevents request alteration and also keeps it compliant with the
    // user-defined CORS policies.
    const acceptHeader = headers.get('accept')
    if (acceptHeader) {
      const values = acceptHeader.split(',').map((value) => value.trim())
      const filteredValues = values.filter(
        (value) => value !== 'msw/passthrough',
      )

      if (filteredValues.length > 0) {
        headers.set('accept', filteredValues.join(', '))
      } else {
        headers.delete('accept')
      }
    }

    return fetch(requestClone, { headers })
  }

  // Bypass mocking when the client is not active.
  if (!client) {
    return passthrough()
  }

  // Bypass initial page load requests (i.e. static assets).
  // The absence of the immediate/parent client in the map of the active clients
  // means that MSW hasn't dispatched the "MOCK_ACTIVATE" event yet
  // and is not ready to handle requests.
  if (!activeClientIds.has(client.id)) {
    return passthrough()
  }

  // Notify the client that a request has been intercepted.
  const serializedRequest = await serializeRequest(event.request)
  const clientMessage = await sendToClient(
    client,
    {
      type: 'REQUEST',
      payload: {
        id: requestId,
        interceptedAt: requestInterceptedAt,
        ...serializedRequest,
      },
    },
    [serializedRequest.body],
  )

  switch (clientMessage.type) {
    case 'MOCK_RESPONSE': {
      return respondWithMock(clientMessage.data)
    }

    case 'PASSTHROUGH': {
      return passthrough()
    }
  }

  return passthrough()
}

/**
 * @param {Client} client
 * @param {any} message
 * @param {Array<Transferable>} transferrables
 * @returns {Promise<any>}
 */
function sendToClient(client, message, transferrables = []) {
  return new Promise((resolve, reject) => {
    const channel = new MessageChannel()

    channel.port1.onmessage = (event) => {
      if (event.data && event.data.error) {
        return reject(event.data.error)
      }

      resolve(event.data)
    }

    client.postMessage(message, [
      channel.port2,
      ...transferrables.filter(Boolean),
    ])
  })
}

/**
 * @param {Response} response
 * @returns {Response}
 */
function respondWithMock(response) {
  // Setting response status code to 0 is a no-op.
  // However, when responding with a "Response.error()", the produced Response
  // instance will have status code set to 0. Since it's not possible to create
  // a Response instance with status code 0, handle that use-case separately.
  if (response.status === 0) {
    return Response.error()
  }

  const mockedResponse = new Response(response.body, response)

  Reflect.defineProperty(mockedResponse, IS_MOCKED_RESPONSE, {
    value: true,
    enumerable: true,
  })

  return mockedResponse
}

/**
 * @param {Request} request
 */
async function serializeRequest(request) {
  return {
    url: request.url,
    mode: request.mode,
    method: request.method,
    headers: Object.fromEntries(request.headers.entries()),
    cache: request.cache,
    credentials: request.credentials,
    destination: request.destination,
    integrity: request.integrity,
    redirect: request.redirect,
    referrer: request.referrer,
    referrerPolicy: request.referrerPolicy,
    body: await request.arrayBuffer(),
    keepalive: request.keepalive,
  }
}

_____________________________

shallwe_frontend/src/app/components/layout/Footer.tsx:

const Footer = () => {
  return (
    <footer className="bg-gray-100 border-t border-gray-200 mt-auto">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-6">
        <div className="md:flex md:items-center md:justify-between">
          <div className="flex justify-center md:justify-start">
            <p className="text-center md:text-left text-sm text-gray-500">
              &copy; {new Date().getFullYear()} Shallwe. All rights reserved.
            </p>
          </div>
          <div className="mt-4 md:mt-0 flex justify-center space-x-6 md:order-2">
            <a
              href="https://github.com/orgs/shallwe-ua/repositories"
              target="_blank"
              rel="noopener noreferrer" // Recommended for security when using target="_blank"
              className="text-gray-400 hover:text-gray-500"
            >
              GitHub
            </a>
            <a
              href="https://www.linkedin.com/in/serhii-soldatov"
              target="_blank"
              rel="noopener noreferrer"
              className="text-gray-400 hover:text-gray-500"
            >
              LinkedIn
            </a>
            <a
              href="https://app.swaggerhub.com/apis/S3MCHANNEL/shallwe-api/0.6.1#"
              target="_blank"
              rel="noopener noreferrer"
              className="text-gray-400 hover:text-gray-500"
            >
              API Reference
            </a>
          </div>
        </div>
      </div>
    </footer>
  )
}

export default Footer

_____________________________

shallwe_frontend/src/app/components/layout/Header.tsx:

'use client'


import Link from 'next/link'
import { usePathname } from 'next/navigation'

import { ApiError } from '@/lib/shallwe/common/api/calls'
import { logout } from '@/lib/shallwe/auth/api/calls'



const Header = () => {

  const pathname = usePathname() // Get current path
  const isLoggedIn = pathname && !['/', '/setup'].includes(pathname) // TODO: USE AUTH CONTEXT LATER !!!!


  const handleLogout = async () => {
    try {
      await logout()
      console.log("Logout successful via API call.")
      handleLogoutSuccess()
    }
    catch (error) {
      handleLogoutError(error)
    }
  }


  const handleLogoutSuccess = () => {
    window.location.href = '/'  // Redirect to home page after logout
  }


  const handleLogoutError = (err: unknown) => {
    const isApiError = (error: any): error is ApiError => {
      return error && typeof error === 'object' && 'message' in error
    }

    console.error("Logout failed:", err)

    if (isApiError(err)) {
      console.error(err.message || "An error occurred during logout.")
    }
    else if (err instanceof Error) {
      console.error(err.message)
    }
    else {
      console.warn("Unexpected error type received in handleLogoutError:", typeof err, err)
    }
  }


  // --- RENDER ---
  return (
    <header className="bg-white shadow-sm">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <div className="flex justify-between items-center h-16">
          <div className="flex-shrink-0">
            <Link href={isLoggedIn ? "/settings" : "/"} className="text-xl font-bold text-primary-blue-dark">
              Shallwe
            </Link>
          </div>
          <nav className="hidden md:block">
            {/* Add navigation links here later if needed, e.g., for logged-out state */}
            {/* Example: <Link href="/about" className="text-gray-700 hover:text-primary-blue mx-3">About</Link> */}
          </nav>
          <div>
            {/* Show logout button if user seems logged in */}
            {isLoggedIn && (
              <button
                onClick={handleLogout}
                className="text-sm font-medium text-gray-700 hover:text-red-600"
              >
                Logout
              </button>
            )}
          </div>
        </div>
      </div>
    </header>
  )
}

export default Header

_____________________________

shallwe_frontend/src/app/components/mock/MSWInit.tsx:

'use client'


import { ReactNode, useEffect, useState } from 'react'


export function MSWInitializer({ children }: { children: ReactNode }) {
  const [ready, setReady] = useState(false)

  useEffect(() => {
    if (!ready) {
      import('@/mocks/browser').then(({ worker }) => {
        worker.start({onUnhandledRequest: 'bypass', }).then(() => {
            setReady(true)
          })
      })
    }
  }, [])

  // This ensures that worker is initialized first before rendering to avoid middleware errors.
  return !ready ? null : <>{children}</> 
}

_____________________________

shallwe_frontend/src/app/components/profile/BirthDateSelect.tsx:

import React, { useState, useEffect } from 'react'
import { isBefore, isAfter, parseISO } from 'date-fns'


interface BirthDateSelectProps {
  inputId: string
  currentValue: string | null // Expecting YYYY-MM-DD string or null
  onChange: (dateString: string) => void // Expecting a valid YYYY-MM-DD string (never null from this component)
  error?: string
  className?: string
}


const BirthDateSelect: React.FC<BirthDateSelectProps> = ({
  inputId,
  currentValue,
  onChange,
  error,
  className = ''
}) => {
  // State for individual date components (always strings, representing valid numbers or empty initially)
  const [day, setDay] = useState<string>('')
  const [month, setMonth] = useState<string>('')
  const [year, setYear] = useState<string>('')
  
  // State to track if date is selected
  const [isInitiated, setIsInitiated] = useState<boolean>(currentValue !== null)

  // Age limits as dates - calculated precisely
  const currentDate = new Date() // Use current date for calculations
  // Calculate exact dates 120 and 16 years ago
  const minSelectableDate = new Date(currentDate.getFullYear() - 120, currentDate.getMonth(), currentDate.getDate())
  const maxSelectableDate = new Date(currentDate.getFullYear() - 16, currentDate.getMonth(), currentDate.getDate())

  // Generate options based on min/max dates
  const minYear = minSelectableDate.getFullYear()
  const maxYear = maxSelectableDate.getFullYear()
  const monthOptions = Array.from({ length: 12 }, (_, i) => (i + 1).toString().padStart(2, '0'))
  const yearOptions = Array.from({ length: maxYear - minYear + 1 }, (_, i) => (maxYear - i).toString())

  // Populate state from currentValue when it changes
  useEffect(() => {
    if (currentValue) {
      try {
        // Parse the input string into a Date object
        const inputDate = parseISO(currentValue) // Handles YYYY-MM-DD format
        // Validate if the date is within the allowed range
        if (isBefore(inputDate, minSelectableDate)) {
             console.warn("BirthDateSelect: currentValue too old (before minSelectableDate):", currentValue, "Min:", minSelectableDate.toISOString().split('T')[0])
             setToMinDate() // Set to the minimum allowed date if too old
             setIsInitiated(true)
             return // Exit early after setting default
        }
        else if (isAfter(inputDate, maxSelectableDate)) {
             console.warn("BirthDateSelect: currentValue too young (after maxSelectableDate):", currentValue, "Max:", maxSelectableDate.toISOString().split('T')[0])
             setToMaxDate() // Set to the maximum allowed date if too young
             setIsInitiated(true)
             return // Exit early after setting default
        }

        // If within range, update state
        const y = inputDate.getFullYear().toString()
        const m = (inputDate.getMonth() + 1).toString().padStart(2, '0') // getMonth is 0-indexed
        const d = inputDate.getDate().toString().padStart(2, '0')

        // Ensure year is within the dynamic range (double-check after parsing)
        if (Number(y) >= minYear && Number(y) <= maxYear) {
            // Check if day is valid for the given month/year, adjust if necessary
            const maxDayForDate = new Date(Number(y), Number(m), 0).getDate()
            const finalDay = Math.min(Number(d), maxDayForDate).toString().padStart(2, '0')
            setYear(y)
            setMonth(m)
            setDay(finalDay)
            setIsInitiated(true)
        } else {
             console.warn("BirthDateSelect: Parsed year out of range:", y, "Expected between", minYear, "and", maxYear)
             setToMaxDate() // Default to max if parsing results in out-of-range year
             setIsInitiated(true)
        }

      } catch (e) {
        console.warn("BirthDateSelect: Invalid currentValue format or parsing error:", currentValue, e)
        // Set to the maximum allowed date if format is invalid or parsing fails
        setToMaxDate()
        setIsInitiated(true)
      }
    }
    else {
      setDay('')
      setMonth('')
      setYear('')
      setIsInitiated(false)
    }

    function setToMinDate() {
         const defaultYear = minSelectableDate.getFullYear().toString()
         const defaultMonth = (minSelectableDate.getMonth() + 1).toString().padStart(2, '0') // getMonth is 0-indexed
         const defaultDay = minSelectableDate.getDate().toString().padStart(2, '0')
         setYear(defaultYear)
         setMonth(defaultMonth)
         setDay(defaultDay)
    }

    function setToMaxDate() {
        const defaultYear = maxSelectableDate.getFullYear().toString()
        const defaultMonth = (maxSelectableDate.getMonth() + 1).toString().padStart(2, '0') // getMonth is 0-indexed
        const defaultDay = maxSelectableDate.getDate().toString().padStart(2, '0')
        setYear(defaultYear)
        setMonth(defaultMonth)
        setDay(defaultDay)
    }
  }, [currentValue, minSelectableDate, maxSelectableDate])


  // --- Calculate days based on selected month and year ---
  const daysInMonth = month && year ? new Date(Number(year), Number(month), 0).getDate() : 31 // Month is 1-indexed for getDate, 0 gets last day of prev month
  const dayOptions = Array.from({ length: daysInMonth }, (_, i) => (i + 1).toString().padStart(2, '0'))

  // Handle change for any select
  const handleSelectChange = (part: 'day' | 'month' | 'year', value: string) => {
    // Update the specific part's state
    let newDay = day
    let newMonth = month
    let newYear = year

    if (part === 'day') newDay = value
    if (part === 'month') newMonth = value
    if (part === 'year') newYear = value

    // If month or year changed, check if the current day is still valid for the new month/year
    if ((part === 'month' || part === 'year') && newMonth && newYear) {
        const maxDayForNewMonth = new Date(Number(newYear), Number(newMonth), 0).getDate()
        // If the currently selected day is too high for the new month/year, adjust it to the maximum allowed
        if (newDay && Number(newDay) > maxDayForNewMonth) {
            newDay = maxDayForNewMonth.toString().padStart(2, '0')
        }
    }

    // If day changed, check if it's valid for the current month/year, adjust if necessary
    if (part === 'day' && newDay && newMonth && newYear) {
        const maxDayForCurrentMonth = new Date(Number(newYear), Number(newMonth), 0).getDate()
        if (Number(newDay) > maxDayForCurrentMonth) {
            newDay = maxDayForCurrentMonth.toString().padStart(2, '0')
        }
    }

    if (newDay && newMonth && newYear) {
      const potentialDate = new Date(Number(newYear), Number(newMonth) - 1, Number(newDay)) // Month is 0-indexed for Date constructor

      if (isBefore(potentialDate, minSelectableDate)) {
        newYear = minSelectableDate.getFullYear().toString()
        newMonth = (minSelectableDate.getMonth() + 1).toString().padStart(2, '0')
        newDay = minSelectableDate.getDate().toString().padStart(2, '0')
      }
      else if (isAfter(potentialDate, maxSelectableDate)) {
        newYear = maxSelectableDate.getFullYear().toString()
        newMonth = (maxSelectableDate.getMonth() + 1).toString().padStart(2, '0')
        newDay = maxSelectableDate.getDate().toString().padStart(2, '0')
      }
    }
    else {
      console.warn("BirthDateSelect: handleSelectChange received empty part, state might be inconsistent.", {part, value, newDay, newMonth, newYear})
    }


    // Update state with potentially adjusted values
    setDay(newDay)
    setMonth(newMonth)
    setYear(newYear)
    setIsInitiated(true)

    // Construct the final date string after all validations and adjustments
    // All parts should be non-empty strings representing valid numbers due to select options and adjustment logic
    if (newDay && newMonth && newYear) {
      const finalDateString = `${newYear}-${newMonth}-${newDay}`
      console.log("BirthDateSelect: Sending adjusted/valid date to parent:", finalDateString)
      onChange(finalDateString) // Always send a valid date string to the parent
    } else {
        // This 'else' block should theoretically never be reached if all logic is correct
        // and select options are properly managed, as state should always hold valid parts.
        // If it somehow happens, send the previous valid date or handle appropriately.
        console.warn("BirthDateSelect: Attempted to send an incomplete date string after adjustments. State might be inconsistent.", {newDay, newMonth, newYear})
    }
  }

  // Handle clicking the select date button
  const handleSelectDateClick = () => {
    // Set to the maximum selectable date (16 years ago) when user clicks the button
    const defaultYear = maxSelectableDate.getFullYear().toString()
    const defaultMonth = (maxSelectableDate.getMonth() + 1).toString().padStart(2, '0') // getMonth is 0-indexed
    const defaultDay = maxSelectableDate.getDate().toString().padStart(2, '0')
    setYear(defaultYear)
    setMonth(defaultMonth)
    setDay(defaultDay)
    setIsInitiated(true)
    
    // Notify parent of the selected date
    const finalDateString = `${defaultYear}-${defaultMonth}-${defaultDay}`
    console.log("BirthDateSelect: Sending initial date to parent:", finalDateString)
    onChange(finalDateString)
  }

  // Determine error state based on the parent's error and potentially internal logic if needed
  // For now, just pass through the parent's error
  const displayError = error

  return (
    <div>
      <label htmlFor={inputId} className="block text-sm font-medium text-gray-700">
        Birth Date (16-120 years old allowed)
      </label>
      <div className="flex flex-row space-x-2 mt-1">
        {!isInitiated ? (
          <div className="sm:col-span-3">
            <button
              type="button"
              onClick={handleSelectDateClick}
              className={`w-full rounded-md border border-gray-300 bg-white px-4 py-2 text-sm font-medium text-gray-700 shadow-sm hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 ${
                displayError ? 'border-red-500' : ''
              } ${className}`}
            >
              Select the date
            </button>
          </div>
        ) : (
          // Show date selects when date is selected
          <>
            {/* Day Select */}
            <div className="flex flex-col"> {/* Container for Day label and select */}
              <label htmlFor={`${inputId}-day`} className="text-xs text-gray-500 mb-1">Day</label>
              <select
                id={`${inputId}-day`}
                value={day}
                onChange={(e) => handleSelectChange('day', e.target.value)}
                className={`rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm ${
                  displayError ? 'border-red-500' : ''
                } ${className}`}
              >
                {dayOptions.map(option => (
                  <option key={option} value={option}>{option}</option>
                ))}
              </select>
            </div>

            {/* Month Select */}
            <div className="flex flex-col"> {/* Container for Month label and select */}
              <label htmlFor={`${inputId}-month`} className="text-xs text-gray-500 mb-1">Month</label>
              <select
                id={`${inputId}-month`}
                value={month}
                onChange={(e) => handleSelectChange('month', e.target.value)}
                className={`rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm ${
                  displayError ? 'border-red-500' : ''
                } ${className}`}
              >
                {monthOptions.map(option => (
                  <option key={option} value={option}>{option}</option>
                ))}
              </select>
            </div>

            {/* Year Select */}
            <div className="flex flex-col"> {/* Container for Year label and select */}
              <label htmlFor={`${inputId}-year`} className="text-xs text-gray-500 mb-1">Year</label>
              <select
                id={`${inputId}-year`}
                value={year}
                onChange={(e) => handleSelectChange('year', e.target.value)}
                className={`rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm ${
                  displayError ? 'border-red-500' : ''
                } ${className}`}
              >
                 {yearOptions.map(option => (
                    <option key={option} value={option}>{option}</option>
                 ))}
              </select>
            </div>
          </>
        )}
      </div>
      {displayError && <p className="mt-1 text-sm text-red-600">{displayError}</p>}
    </div>
  )
}

export default BirthDateSelect

_____________________________

shallwe_frontend/src/app/components/profile/Locations.tsx:

import React, { useState, useEffect, useCallback, useRef } from 'react'
import { searchLocations } from '@/lib/shallwe/locations/api/calls'
import { LocationsReadFields } from '@/lib/shallwe/locations/api/schema'
import { ApiError } from '@/lib/shallwe/common/api/calls'

interface LocationsProps {
  selectedLocations: string[]
  initialLocationNames?: Record<string, string>
  onLocationsChange: (newLocations: string[]) => void
  error?: string
  onClearError: () => void
}

const MAX_LOCATIONS = 30;

const Locations: React.FC<LocationsProps> = ({
  selectedLocations,
  initialLocationNames,
  onLocationsChange,
  error,
  onClearError,
}) => {
  const [searchQuery, setSearchQuery] = useState('')
  const [searchResults, setSearchResults] = useState<LocationsReadFields | null>(null)
  const [isLoading, setIsLoading] = useState(false)
  const [searchError, setSearchError] = useState<string | null>(null)
  const [showResults, setShowResults] = useState(false)
  const [nameMap, setNameMap] = useState<Record<string, string>>(initialLocationNames || {})
  const [isInputFrozen, setIsInputFrozen] = useState(false);
  const [isCounterSwinging, setIsCounterSwinging] = useState(false);

  const wrapperRef = useRef<HTMLDivElement>(null)

  // üß† Close search results when clicking outside
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (wrapperRef.current && !wrapperRef.current.contains(event.target as Node)) {
        setShowResults(false)
        setIsInputFrozen(false);
        setIsCounterSwinging(false);
      }
    }
    document.addEventListener('mousedown', handleClickOutside)
    return () => document.removeEventListener('mousedown', handleClickOutside)
  }, [])

  const areOverlappingHierarchies = (h1: string, h2: string) => {
    return h1.startsWith(h2) || h2.startsWith(h1)
  }

  const handleSelectLocation = (selectedHierarchy: string, displayName: string) => {
    if (selectedLocations.length >= MAX_LOCATIONS && !selectedLocations.includes(selectedHierarchy)) {
      setIsInputFrozen(true);
      setIsCounterSwinging(true);
      setTimeout(() => setIsCounterSwinging(false), 500); // Swing animation duration
      return;
    }

    onClearError()
    setSearchError(null)

    // Toggle if already selected
    let newLocations: string[]
    if (selectedLocations.includes(selectedHierarchy)) {
      newLocations = selectedLocations.filter((h) => h !== selectedHierarchy)
    } else {
      // Remove overlapping ones
      newLocations = selectedLocations.filter(
        (existingHierarchy) => !areOverlappingHierarchies(selectedHierarchy, existingHierarchy)
      )
      newLocations.push(selectedHierarchy)
      setNameMap((prev) => ({ ...prev, [selectedHierarchy]: displayName }))
    }

    onLocationsChange(newLocations)
    // Only unfreeze if we're below the limit
    if (newLocations.length < MAX_LOCATIONS) {
      setIsInputFrozen(false);
      setIsCounterSwinging(false);
    }
  }

  const handleRemoveLocation = (hierarchyToRemove: string) => {
    onClearError()
    const newLocations = selectedLocations.filter((h) => h !== hierarchyToRemove)
    onLocationsChange(newLocations)
    
    // Unfreeze input when removing a location since we're now below the limit
    setIsInputFrozen(false);
    setIsCounterSwinging(false);
  }

  const debouncedSearch = useCallback(
    (query: string) => {
      const search = async () => {
        if (query.length < 2) {
          setSearchResults(null)
          setSearchError(null)
          return
        }

        setIsLoading(true)
        setSearchError(null)
        try {
          const results = await searchLocations(query)
          setSearchResults(results)
          setShowResults(true)
        } catch (err) {
          console.error('Error searching locations:', err)
          setSearchResults(null)
          const apiError = err as ApiError
          if ('status' in apiError && apiError.status === 404) {
            setSearchError('No locations matching this query. Please check the spelling.')
          }
          else setSearchError(`Error trying to search locations: ${apiError.message}`)
        } finally {
          setIsLoading(false)
        }
      }

      search()
    },
    []
  )

  useEffect(() => {
    if (searchQuery.length < 2) {
      setSearchResults(null)
      setSearchError(null)
      return
    }
    const timer = setTimeout(() => {
      debouncedSearch(searchQuery)
    }, 300)
    return () => clearTimeout(timer)
  }, [searchQuery, debouncedSearch])

  const showAllUkraineTag = selectedLocations.length === 0

  const getDisplayName = (entity: any, type: 'region' | 'city' | 'other_ppl' | 'district', parentCity?: { ppl_name: string }): string => {
    switch (type) {
      case 'region':
        return entity.region_name;
      case 'city':
        // Big cities: City Name (Region Name)
        return `${entity.ppl_name} (${entity.region_name})`;
      case 'district':
        if (!parentCity) {
          console.error("getDisplayName: parentCity is required for type 'district'", { entity, type, parentCity });
          // Return a fallback string indicating the error, or just the district name
          // Returning just the district name might be less disruptive than showing an error string like "[Missing Parent City]"
          return `${entity.district_name} ${entity.hierarchy}` || `[Missing Parent City for ${entity.hierarchy}]`
        }
        // Districts: City Name, District Name (e.g., –ö–∏—ó–≤, –ü–æ–¥—ñ–ª—å—Å–∫–∏–π)
        // parentCity is expected for districts
        return `${parentCity.ppl_name}, ${entity.district_name}`
      case 'other_ppl':
        // Other PPLs: Name (Region, Subregion) or Name (Region)
        const suffix = entity.subregion_name ? `${entity.region_name}, ${entity.subregion_name}` : entity.region_name;
        return `${entity.ppl_name} (${suffix})`;
      default:
        // Fallback to hierarchy string if type is unknown
        return entity.hierarchy || '';
    }
  };

  // Simplified render item function that just receives the display name string
  const renderResultItem = (hierarchy: string, displayName: string) => (
    <div
      key={hierarchy}
      onClick={() => handleSelectLocation(hierarchy, displayName)} // Pass the pre-formatted display name
      className={`p-2 text-sm cursor-pointer hover:bg-gray-100 ${
        selectedLocations.includes(hierarchy) ? 'bg-green-100 hover:bg-green-200' : ''
      } ${selectedLocations.length >= MAX_LOCATIONS && !selectedLocations.includes(hierarchy) ? 'opacity-50 cursor-not-allowed' : ''}`}
    >
      {displayName}
    </div>
  );

  return (
    <div className="space-y-2 relative" ref={wrapperRef}>
      {/* Search field */}
      <div className="relative">
        <input
          type="text"
          id="location-search"
          value={searchQuery}
          onChange={(e) => {
            if (!isInputFrozen) {
              setSearchQuery(e.target.value);
            }
          }}
          placeholder="Enter location..."
          onFocus={() => {
            if (selectedLocations.length >= MAX_LOCATIONS) {
              setIsInputFrozen(true);
              setIsCounterSwinging(true);
              setTimeout(() => setIsCounterSwinging(false), 500);
            } else {
              searchResults && setShowResults(true);
            }
          }}
          className={`mt-1 block w-full rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm ${
            isInputFrozen 
              ? 'border-red-500 bg-red-50 cursor-not-allowed' 
              : searchError 
                ? 'border-red-500' 
                : 'border-gray-300'
          }`}
          disabled={isInputFrozen}
        />
        {isLoading && (
          <div className="absolute inset-y-0 right-0 flex items-center pr-3">
            <div className="animate-spin rounded-full h-5 w-5 border-b-2 border-indigo-600"></div>
          </div>
        )}
      </div>

      {searchError && <p className="mt-1 text-sm text-gray-400">{searchError}</p>}
      {error && <p className="mt-1 text-sm text-red-600">{error}</p>}

      {/* Location Counter */}
      <div className={`text-sm font-medium text-gray-400 transition-colors duration-300 flex justify-between items-center`}>
        <span 
          className={`inline-block ${isCounterSwinging ? 'animate-pulse text-red-600' : ''}`}
        >
          {selectedLocations.length}/{MAX_LOCATIONS} locations picked
        </span>
        {selectedLocations.length > 0 && (
          <button
            type="button"
            onClick={() => {
              onLocationsChange([]);
              setNameMap({});
              setIsInputFrozen(false);
              setIsCounterSwinging(false);
            }}
            className="text-sm text-gray-400 hover:text-gray-700 cursor-pointer underline"
          >
            clear all &times;
          </button>
        )}
      </div>

      {/* Search Results Dropdown (absolute overlay) */}
      {showResults && searchResults && (
        <div
          className="absolute left-0 right-0 bg-white border border-gray-200 rounded-md max-h-60 overflow-y-auto z-50 shadow-lg"
        >
          {/* Regions */}
          {searchResults.regions && searchResults.regions.length > 0 && (
            <div className="p-2">
              <h3 className="text-xs font-medium text-gray-500 uppercase tracking-wide">Regions</h3>
              {searchResults.regions.map((region) => {
                const displayName = getDisplayName(region, 'region');
                return renderResultItem(region.hierarchy, displayName);
              })}
            </div>
          )}
          {/* Cities */}
          {searchResults.cities && searchResults.cities.length > 0 && (
            <div className="p-2">
              <h3 className="text-xs font-medium text-gray-500 uppercase tracking-wide">Cities</h3>
              {searchResults.cities.map((city) => (
                <React.Fragment key={city.hierarchy}>
                  {/* Render the main city */}
                  {renderResultItem(city.hierarchy, getDisplayName(city, 'city'))}
                  {/* Render nested districts */}
                  {city.districts && city.districts.length > 0 && (
                    <div className="ml-4">
                      {city.districts.map((district) => {
                        const displayName = getDisplayName(district, 'district', city); // Pass the parent city
                        return renderResultItem(district.hierarchy, displayName);
                      })}
                    </div>
                  )}
                </React.Fragment>
              ))}
            </div>
          )}
          {/* Other */}
          {searchResults.other_ppls && searchResults.other_ppls.length > 0 && (
            <div className="p-2">
              <h3 className="text-xs font-medium text-gray-500 uppercase tracking-wide">Other</h3>
              {searchResults.other_ppls.map((ppl) => {
                const displayName = getDisplayName(ppl, 'other_ppl');
                return renderResultItem(ppl.hierarchy, displayName);
              })}
            </div>
          )}
        </div>
      )}

      {/* Selected Tags */}
      <div className="mt-2 flex flex-wrap gap-2">
        {showAllUkraineTag ? (
          <span className="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-100 text-gray-800">
            –í—Å—è –£–∫—Ä–∞—ó–Ω–∞ (Default)
          </span>
        ) : (
          selectedLocations.map((loc) => (
            <span
              key={loc}
              className="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-indigo-100 text-indigo-800"
            >
              {nameMap[loc] || loc}
              <button
                type="button"
                onClick={() => handleRemoveLocation(loc)}
                className="ml-2 text-indigo-600 hover:bg-indigo-200 hover:text-indigo-800 rounded-full p-0.5"
              >
                <svg className="h-3 w-3" stroke="currentColor" fill="none" viewBox="0 0 8 8">
                  <path strokeLinecap="round" strokeWidth="1.5" d="M1 1l6 6m0-6L1 7" />
                </svg>
              </button>
            </span>
          ))
        )}
      </div>
    </div>
  )
}

export default Locations

_____________________________

shallwe_frontend/src/app/components/profile/PhotoWithFallbacks.tsx:

import React, { useState, useEffect } from 'react';

interface PhotoWithFallbacksProprs {
  src: string;
  fallbackSrc?: string; // URL for the default image
  alt: string;
  className?: string; // Allow passing Tailwind classes for styling
}

const PhotoWithFallbacks: React.FC<PhotoWithFallbacksProprs> = ({ 
  src, 
  fallbackSrc = '/img/profile/default192.webp', // Default fallback image path
  alt, 
  className = '' 
}) => {
  const [currentSrc, setCurrentSrc] = useState<string>(src);
  const [hasError, setHasError] = useState<boolean>(false);
  const [isLoading, setIsLoading] = useState<boolean>(true); // Optional: for loading state

  // Reset state when the primary `src` prop changes
  useEffect(() => {
    setCurrentSrc(src);
    setHasError(false);
    setIsLoading(true); // Optional
  }, [src]);

  const handleError = () => {
    // If the primary image failed and we have a fallback, try the fallback
    if (!hasError && fallbackSrc && currentSrc !== fallbackSrc) {
      console.log(`ImageWithFallbacks: Error loading ${currentSrc}, trying fallback ${fallbackSrc}`);
      setCurrentSrc(fallbackSrc);
    } else {
      // If fallback also fails, or there's no fallback, or it was already tried, show error/SVG
      console.log(`ImageWithFallbacks: Error loading image ${currentSrc}, showing fallback UI.`);
      setHasError(true);
      setIsLoading(false); // Optional
    }
  };

  const handleLoad = () => {
    // Image loaded successfully
    console.log(`ImageWithFallbacks: Successfully loaded ${currentSrc}`);
    setIsLoading(false); // Optional
  };

  // If there was an error loading both primary and fallback, show SVG
  if (hasError) {
    return (
      <div className={`flex items-center justify-center bg-gray-200 ${className}`}>
        <svg 
          className="w-16 h-16 text-gray-400" // Adjust size and color as needed
          fill="currentColor" 
          viewBox="0 0 24 24" 
          aria-hidden="true"
        >
          <path d="M24 20.993V24H0v-2.996A14.977 14.977 0 0112.004 15c4.904 0 9.26 2.354 11.996 5.993zM16.002 8.999a4 4 0 11-8 0 4 4 0 018 0z" />
        </svg>
        <span className="sr-only">{alt}</span> {/* For accessibility */}
      </div>
    );
  }

  // Render the img tag with the current source (primary or fallback)
  return (
    <img
      src={currentSrc}
      alt={alt}
      className={className}
      onError={handleError}
      onLoad={handleLoad}
    />
  );
};

export default PhotoWithFallbacks;
_____________________________

shallwe_frontend/src/app/components/profile/ProfileEditView.tsx:

'use client'

import { useState, useCallback, useMemo, useEffect } from 'react'
import { useRouter } from 'next/navigation'
import { updateProfile } from '@/lib/shallwe/profile/api/calls' // Import update API call
import { ProfileUpdateFormState, getProfileUpdateFormStateInitial } from '@/lib/shallwe/profile/formstates/states' // Import NEW update form state and its initializer
import { collectProfileUpdateDataFromState } from '@/lib/shallwe/profile/formstates/collectors/update' // Import the NEW collector
import { validateProfileUpdateFields } from '@/lib/shallwe/profile/formstates/validators/update' // Import the NEW validator
import { ProfileUpdateData } from '@/lib/shallwe/profile/api/schema/update' // Import update schema
import { ProfileReadData } from '@/lib/shallwe/profile/api/schema/read' // Import read schema to get original data
import { ApiError } from '@/lib/shallwe/common/api/calls' // Import ApiError type
import ProfilePhotoPick from '@/app/components/profile/ProfilePhotoPick' // Assuming this is the correct path
import Locations from '@/app/components/profile/Locations' // Assuming this is the correct path
import { ValidationResult, validators } from '@/lib/shallwe/profile/formstates/validators/common'
import { TagsInput } from 'react-tag-input-component'
import BirthDateSelect from './BirthDateSelect'

// Define the props for the edit view
interface ProfileEditViewProps {
  initialProfileData: ProfileReadData // Pass the current profile data fetched on the server
  onSave: () => void // Callback to notify parent when save is successful
  onCancel: () => void // Callback to notify parent when edit is cancelled
}

export const ProfileEditView: React.FC<ProfileEditViewProps> = ({ initialProfileData, onSave, onCancel }) => {
  const router = useRouter()

  // Initialize editFormState using the NEW initializer function
  const initialEditFormState: ProfileUpdateFormState = getProfileUpdateFormStateInitial(initialProfileData)

  const [editFormState, setEditFormState] = useState<ProfileUpdateFormState>(initialEditFormState)
  const [errors, setErrors] = useState<Record<string, string>>({})
  const [apiError, setApiError] = useState<string | null>(null)
  const [isFloatingApiErrorDismissed, setIsFloatingApiErrorDismissed] = useState(false)
  const [isSaving, setIsSaving] = useState(false)

  // Reset dismissal state if apiError changes (e.g., a new error occurs, or error is cleared)
  useEffect(() => {
    if (apiError) {
      setIsFloatingApiErrorDismissed(false); // Reset dismissal if a new error appears
    }
  }, [apiError]); // Run effect when apiError changes

  const initialLocationNamesMap = useMemo(() => {
    const map: Record<string, string> = {};
    const locationsData = initialProfileData.rent_preferences.locations; // This is LocationsReadFields

    // Populate map from regions
    locationsData.regions?.forEach(region => {
      map[region.hierarchy] = region.region_name;
    });

    // Populate map from cities
    locationsData.cities?.forEach(city => {
      // Format city name like in getDisplayName (e.g., "Kyiv (Kyivska)")
      map[city.hierarchy] = `${city.ppl_name} (${city.region_name})`;
      // Populate map from districts within cities
      city.districts?.forEach(district => {
        // Format district name like in getDisplayName (e.g., "Kyiv, Podilskyi")
        map[district.hierarchy] = `${city.ppl_name}, ${district.district_name}`;
      });
    });

    // Populate map from other_ppls
    locationsData.other_ppls?.forEach(otherPpl => {
      // Format other_ppl name like in getDisplayName
      const suffix = otherPpl.subregion_name ? `${otherPpl.region_name}, ${otherPpl.subregion_name}` : otherPpl.region_name;
      map[otherPpl.hierarchy] = `${otherPpl.ppl_name} (${suffix})`;
    });

    return map;
  }, [initialProfileData]); // Recalculate if initialProfileData changes


  const hasChanges = useMemo(() => {
    const updatePayload = collectProfileUpdateDataFromState(editFormState, initialProfileData);
    // Check if the collected payload has any properties (changes to send)
    return Object.keys(updatePayload).length > 0;
  }, [editFormState, initialProfileData]); // Re-run when form state or initial data changes


  const updateSmokingLevelAndClearTypes = (newLevel: ProfileUpdateFormState['about']['smoking_level']) => {
    setEditFormState(prev => {
      const updatedAbout = { ...prev.about, smoking_level: newLevel };

      // Check if the new level is null or 1
      if (newLevel === null || newLevel === 1) {
        // Reset smoking type booleans to false
        updatedAbout.smokes_iqos = false;
        updatedAbout.smokes_vape = false;
        updatedAbout.smokes_tobacco = false;
        updatedAbout.smokes_cigs = false;
      }

      return {
        ...prev,
        about: updatedAbout,
      };
    });

    // Clear specific field error when user starts typing/modifying
    if (errors['about.smoking_level']) {
      setErrors(prev => {
        const newErrors = { ...prev };
        delete newErrors['about.smoking_level'];
        return newErrors;
      });
    }
  };


  // Helper to safely update nested state - adapted for ProfileUpdateFormState
  const updateEditFormState = <S extends keyof ProfileUpdateFormState, F extends keyof ProfileUpdateFormState[S]>(
    section: S, field: F, value: ProfileUpdateFormState[S][F]
  ) => {
    setEditFormState(prev => ({
      ...prev,
      [section]: {
        ...prev[section],
        [field]: value,
      },
    }))
    // Clear specific field error when user starts typing/modifying
    if (errors[`${section}.${String(field)}`]) {
      setErrors(prev => {
        const newErrors = { ...prev }
        delete newErrors[`${section}.${String(field)}`]
        return newErrors
      })
    }
  }

  // Handler for PhotoCropper to update the photo state
  const handlePhotoCropped = (croppedFile: File) => {
    updateEditFormState('profile', 'photo', croppedFile) // This now updates the File | null field
  }

  // Handler for PhotoCropper to set error
  const handlePhotoError = (error: string) => {
    setErrors(prevErrors => ({
        ...prevErrors,
        'profile.photo': error
    }))
  }

  // Handler for PhotoCropper to clear its error
  const clearPhotoError = () => {
    setErrors(prevErrors => {
        const newErrors = { ...prevErrors }
        delete newErrors['profile.photo']
        return newErrors
    })
  }

  // Handler for LocationSearch to update locations state
  const handleLocationsChange = (newLocations: string[]) => {
    updateEditFormState('rent_preferences', 'locations', newLocations)
  }

  // Handler for LocationSearch to clear its error
  const clearLocationsError = () => {
    setErrors(prevErrors => {
        const newErrors = { ...prevErrors }
        delete newErrors['rent_preferences.locations']
        return newErrors
    })
  }

  // Validation function for the current state of editFormState - using NEW validator
  // It validates fields that are *present* in the editFormState (i.e., potentially changed fields)
  // The NEW validator likely needs the list of fields to validate.
  // You might need to define which fields are relevant for the current edit view,
  // or validate all possible fields if the validator handles non-present fields gracefully.
  // For now, let's assume it validates fields present in the state or a predefined list.
  // Define fields belonging to each section for validation (similar to ProfileSetupPage)
  const PROFILE_FIELDS_TO_VALIDATE = ['profile.name', 'profile.photo']
  const ABOUT_FIELDS_TO_VALIDATE = [
    'about.birth_date', 'about.gender', 'about.is_couple', 'about.has_children',
    'about.smoking_level', 'about.other_animals', 'about.interests', 'about.bio',
    'about.occupation_type', 'about.drinking_level', 'about.neighbourliness_level',
    'about.guests_level', 'about.parties_level', 'about.bedtime_level', 'about.neatness_level',
    'about.has_cats', 'about.has_dogs', 'about.has_reptiles', 'about.has_birds',
    'about.smokes_iqos', 'about.smokes_vape', 'about.smokes_tobacco', 'about.smokes_cigs',
  ]
  const RENT_PREFERENCES_FIELDS_TO_VALIDATE = [
    'rent_preferences.min_budget', 'rent_preferences.max_budget',
    'rent_preferences.min_rent_duration_level', 'rent_preferences.max_rent_duration_level',
    'rent_preferences.room_sharing_level', 'rent_preferences.locations',
  ]

  // Define a helper function to run validation and update errors
  const validateCurrentTagsInput = (fieldName: string, tagsToValidate: string[], validatorKey: string) => {
    const validationError = validators[validatorKey](tagsToValidate, editFormState);
    setErrors(prevErrors => {
      const newErrors = { ...prevErrors };
      if (validationError !== null) {
        newErrors[fieldName] = validationError;
      } else {
        delete newErrors[fieldName]; // Clear error if validation passes
      }
      return newErrors;
    });
    return validationError
  };

  const validateEditForm = (): boolean => {
    // Combine all fields that could be validated during an update
    const allFieldsToValidate = [
      ...PROFILE_FIELDS_TO_VALIDATE,
      ...ABOUT_FIELDS_TO_VALIDATE,
      ...RENT_PREFERENCES_FIELDS_TO_VALIDATE,
    ]

    // Use the NEW update validator
    const validation: ValidationResult = validateProfileUpdateFields(editFormState, allFieldsToValidate)
    setErrors(validation.errors)
    return validation.isValid
  }

  // Save function
  const handleSave = async () => {
    if (!validateEditForm()) {
      console.log("Edit form validation failed.")
      return
    }

    setIsSaving(true)
    setApiError(null)

    try {
      // Use the NEW collector to determine the payload based on differences between editFormState and initialProfileData
      const profileDataToUpdate: ProfileUpdateData = collectProfileUpdateDataFromState(editFormState, initialProfileData)

      console.log("Collected Profile Data for Update API:", profileDataToUpdate)

      // Call the updateProfile API function with the structured data object
      await updateProfile(profileDataToUpdate)
      console.log("Profile updated successfully!")
      onSave() // Notify parent component of success
    } catch (error) {
      console.error("Error updating profile:", error)
      setIsSaving(false)
      let errorMessage = "Failed to update profile."
      if (error && typeof error === 'object' && 'details' in error) {
        const err = error as ApiError
        if (typeof err.details === 'string') {
            errorMessage = err.details
        } else if (typeof err.details === 'object' && err.details && 'error' in err.details) {
            // Attempt to parse field-specific errors from the API
            const apiErrors = err.details.error
            if (typeof apiErrors === 'object') {
                setErrors(apiErrors) // This might require flattening the nested error structure
                errorMessage = JSON.stringify(apiErrors)
            } else if (typeof apiErrors === 'string') {
                errorMessage = apiErrors
            }
        }
      } else if (error instanceof Error) {
        errorMessage = error.message
      }
      setApiError(errorMessage)
    } finally {
      setIsSaving(false)
    }
  }

  // --- RENDER LOGIC ---
  return (
    <div className="space-y-6">
      {/* API Error Display - Floating Notification (only if not dismissed) */}
      {apiError && !isFloatingApiErrorDismissed && (
        <div className="fixed inset-x-0 bottom-4 flex items-center justify-center pointer-events-none z-50">
          <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded-lg shadow-lg max-w-md w-full mx-4 pointer-events-auto relative">
            <span className="block sm:inline">API Error: {apiError}</span>
            <button
              type="button"
              onClick={() => setIsFloatingApiErrorDismissed(true)} // Dismiss the floating notification only
              className="absolute top-1 right-1 text-red-700 hover:text-red-900 focus:outline-none"
              aria-label="Dismiss floating error"
            >
              &times;
            </button>
          </div>
        </div>
      )}

      {/* API Error Display - Original Inline Version (only if floating was dismissed) */}
      {apiError && isFloatingApiErrorDismissed && (
        <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded relative" role="alert">
          <span className="block sm:inline">API Error: {apiError}</span>
        </div>
      )}

      {/* Profile Data Display */}
      <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
        {/* Photo and Basic Info */}
        <div className="md:col-span-1 flex flex-col items-center">
          {/* Photo Cropper Component */}
          {/* Pass the existing photo URL from initialProfileData for display */}
          {/* Pass the cropped file handler */}
          {/* Pass error and clear error handlers */}
          <ProfilePhotoPick
            initialFile={editFormState.profile.photo} // null if no new file, File if new file selected/cropped
            initialPhotoUrl={initialProfileData.profile.photo_w192 || null} // URL of existing photo
            onError={handlePhotoError}
            onClearError={clearPhotoError}
            onCropComplete={handlePhotoCropped}
          />
          {/* Display central validation error for photo if it exists */}
          {errors['profile.photo'] && <p className="mt-1 text-sm text-red-600">{errors['profile.photo']}</p>}

          <h2 className="text-xl font-semibold text-center mt-2">
            {/* Name Input */}
            <input
              type="text"
              value={editFormState.profile.name ?? ''} // Handle potential null
              onChange={(e) => updateEditFormState('profile', 'name', e.target.value)}
              className={`mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm ${
                errors['profile.name'] ? 'border-red-500' : ''
              }`}
            />
            {errors['profile.name'] && <p className="mt-1 text-sm text-red-600">{errors['profile.name']}</p>}
          </h2>
          {/* Profile visibility status is likely not editable here, just displayed */}
          <p className="text-gray-600 text-center">({initialProfileData.profile.is_hidden ? 'Hidden' : 'Visible'})</p>
        </div>

        {/* Main Details */}
        <div className="md:col-span-2 space-y-4">
          <div className="grid grid-cols-2 gap-4">

            {/* Birth Date */}
            <BirthDateSelect
              inputId="birth_date"
              currentValue={editFormState.about.birth_date} // Pass the string value from state
              onChange={(dateString) => updateEditFormState('about', 'birth_date', dateString)} // Pass the update handler
              error={errors['about.birth_date']} // Pass the error message
              className={`${errors['about.birth_date'] ? 'border-red-500' : ''}`} // Pass specific Tailwind classes if needed
            />

            {/* Gender */}
            <div>
              <label className="block text-sm font-medium text-gray-700">Gender</label>
              <div className="mt-1 space-y-2">
                {[
                  { id: 'gender_male_edit', value: 1, label: 'Male' },
                  { id: 'gender_female_edit', value: 2, label: 'Female' },
                ].map((option) => (
                  <div key={option.id} className="flex items-center">
                    <input
                      id={option.id}
                      name="gender_edit"
                      type="radio"
                      checked={editFormState.about.gender === option.value}
                      onChange={() => updateEditFormState('about', 'gender', option.value as 1 | 2)}
                      className="h-4 w-4 border-gray-300 text-indigo-600 focus:ring-indigo-500"
                    />
                    <label htmlFor={option.id} className="ml-3 block text-sm text-gray-700">
                      {option.label}
                    </label>
                  </div>
                ))}
              </div>
              {errors['about.gender'] && <p className="mt-1 text-sm text-red-600">{errors['about.gender']}</p>}
            </div>
            {/* Is Couple */}
            <div className="flex flex-col mt-2">
              <div className="flex items-center">
                <input
                  id="is_couple_edit"
                  type="checkbox"
                  checked={editFormState.about.is_couple === true}
                  onChange={(e) => updateEditFormState('about', 'is_couple', e.target.checked)}
                  className="h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500"
                />
                <label htmlFor="is_couple_edit" className="ml-2 block text-sm text-gray-700">
                  Is Couple
                </label>
              </div>
              {errors['about.is_couple'] && <p className="mt-1 text-sm text-red-600">{errors['about.is_couple']}</p>}
            </div>
            {/* Has Children */}
            <div className="flex flex-col mt-2">
              <div className="flex items-center">
                <input
                  id="has_children_edit"
                  type="checkbox"
                  checked={editFormState.about.has_children === true}
                  onChange={(e) => updateEditFormState('about', 'has_children', e.target.checked)}
                  className="h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500"
                />
                <label htmlFor="has_children_edit" className="ml-2 block text-sm text-gray-700">
                  Has Children
                </label>
              </div>
              {errors['about.has_children'] && <p className="mt-1 text-sm text-red-600">{errors['about.has_children']}</p>}
            </div>
            {/* Add more fields as needed, mirroring the structure from ProfileSetupPage for the 'about' section */}
            {/* Example: Occupation Type */}
            <div>
              <label htmlFor="occupation_type_edit" className="block text-sm font-medium text-gray-700">
                Occupation Type
              </label>
              <select
                id="occupation_type_edit"
                value={editFormState.about.occupation_type ?? ''} // Handle potential null
                onChange={(e) => updateEditFormState('about', 'occupation_type', e.target.value ? Number(e.target.value) as 1 | 2 | 3 | 4 : null)} // Send null if empty string
                className={`mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm ${
                  errors['about.occupation_type'] ? 'border-red-500' : ''
                }`}
              >
                <option value="">Select...</option>
                <option value="1">Employed</option>
                <option value="2">Student</option>
                <option value="3">Unemployed</option>
                <option value="4">Retired</option>
              </select>
              {errors['about.occupation_type'] && <p className="mt-1 text-sm text-red-600">{errors['about.occupation_type']}</p>}
            </div>
            {/* Example: Drinking Level */}
            <div>
              <label htmlFor="drinking_level_edit" className="block text-sm font-medium text-gray-700">
                Drinking Level
              </label>
              <select
                id="drinking_level_edit"
                value={editFormState.about.drinking_level ?? ''} // Handle potential null
                onChange={(e) => updateEditFormState('about', 'drinking_level', e.target.value ? Number(e.target.value) as 1 | 2 | 3 | 4 : null)} // Send null if empty string
                className={`mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm ${
                  errors['about.drinking_level'] ? 'border-red-500' : ''
                }`}
              >
                <option value="">Select...</option>
                <option value="1">Never</option>
                <option value="2">Rarely</option>
                <option value="3">Socially</option>
                <option value="4">Often</option>
              </select>
              {errors['about.drinking_level'] && <p className="mt-1 text-sm text-red-600">{errors['about.drinking_level']}</p>}
            </div>

            <div>
              <label htmlFor="smoking_level_edit" className="block text-sm font-medium text-gray-700">
                Smoking Level
              </label>
              <select
                id="smoking_level_edit"
                value={editFormState.about.smoking_level ?? ''} // Handle potential null
                onChange={(e) => updateSmokingLevelAndClearTypes(e.target.value ? Number(e.target.value) as 1 | 2 | 3 | 4 : null)}
                className={`mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm ${
                  errors['about.smoking_level'] ? 'border-red-500' : ''
                }`}
              >
                <option value="">Select...</option>
                <option value="1">Never</option>
                <option value="2">Rarely</option>
                <option value="3">Socially</option>
                <option value="4">Often</option>
              </select>
              {errors['about.smoking_level'] && <p className="mt-1 text-sm text-red-600">{errors['about.smoking_level']}</p>}
            </div>

            {/* Add Smoking Type Checkboxes (Conditional based on smoking_level) - ADD THIS BLOCK */}
            {editFormState.about.smoking_level !== null && editFormState.about.smoking_level > 1 && (
              <div className="col-span-2 mt-2"> {/* Use col-span-2 to span full width, add top margin */}
                <p className="text-sm font-medium text-gray-700 mb-1">Smoking Types:</p> {/* Label for the group */}
                <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-4 gap-2 ml-2"> {/* Grid layout: 1 column on mobile, 2 on small screens, 4 on medium+ screens */}
                  <div className="flex items-center">
                    <input
                      id="smokes_iqos_edit"
                      type="checkbox"
                      checked={editFormState.about.smokes_iqos === true}
                      onChange={(e) => updateEditFormState('about', 'smokes_iqos', e.target.checked)}
                      className="h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500"
                    />
                    <label htmlFor="smokes_iqos_edit" className="ml-2 block text-sm text-gray-700">
                      IQOS
                    </label>
                  </div>
                  <div className="flex items-center">
                    <input
                      id="smokes_vape_edit"
                      type="checkbox"
                      checked={editFormState.about.smokes_vape === true}
                      onChange={(e) => updateEditFormState('about', 'smokes_vape', e.target.checked)}
                      className="h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500"
                    />
                    <label htmlFor="smokes_vape_edit" className="ml-2 block text-sm text-gray-700">
                      Vape
                    </label>
                  </div>
                  <div className="flex items-center">
                    <input
                      id="smokes_tobacco_edit"
                      type="checkbox"
                      checked={editFormState.about.smokes_tobacco === true}
                      onChange={(e) => updateEditFormState('about', 'smokes_tobacco', e.target.checked)}
                      className="h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500"
                    />
                    <label htmlFor="smokes_tobacco_edit" className="ml-2 block text-sm text-gray-700">
                      Tobacco
                    </label>
                  </div>
                  <div className="flex items-center">
                    <input
                      id="smokes_cigs_edit"
                      type="checkbox"
                      checked={editFormState.about.smokes_cigs === true}
                      onChange={(e) => updateEditFormState('about', 'smokes_cigs', e.target.checked)}
                      className="h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500"
                    />
                    <label htmlFor="smokes_cigs_edit" className="ml-2 block text-sm text-gray-700">
                      Cigarettes
                    </label>
                  </div>
                </div>
              </div>
            )}
            {/* End of Smoking Type Checkboxes block */}
          </div>

          {/* Rent Preferences */}
          <div className="mt-4 p-4 bg-gray-50 rounded-lg">
            <h3 className="text-lg font-medium text-gray-900 mb-2">Rent Preferences</h3>
            <div className="grid grid-cols-2 gap-4">
              
              <div>
                <label htmlFor="min_budget_edit" className="block text-sm font-medium text-gray-700">
                  Min Budget
                </label>
                <input
                  type="number"
                  id="min_budget_edit"
                  value={editFormState.rent_preferences.min_budget}
                  onChange={(e) => {
                    const raw = e.target.value;
                    const cleaned = raw.length > 1 ? raw.replace(/^0+(?=\d)/, '') : raw;
                    if (cleaned !== raw) e.target.value = cleaned
                    updateEditFormState('rent_preferences', 'min_budget', Number(cleaned));
                  }}
                  className={`mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm ${
                    errors['rent_preferences.min_budget'] ? 'border-red-500' : ''
                  }`}
                />
                {errors['rent_preferences.min_budget'] && <p className="mt-1 text-sm text-red-600">{errors['rent_preferences.min_budget']}</p>}
              </div>

              <div>
                <label htmlFor="max_budget_edit" className="block text-sm font-medium text-gray-700">
                  Max Budget
                </label>
                <input
                  type="number"
                  id="max_budget_edit"
                  value={editFormState.rent_preferences.max_budget}
                  onChange={(e) => {
                    const raw = e.target.value;
                    const cleaned = raw.length > 1 ? raw.replace(/^0+(?=\d)/, '') : raw;
                    if (cleaned !== raw) e.target.value = cleaned
                    updateEditFormState('rent_preferences', 'max_budget', Number(cleaned));
                  }}
                  className={`mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm ${
                    errors['rent_preferences.max_budget'] ? 'border-red-500' : ''
                  }`}
                />
                {errors['rent_preferences.max_budget'] && <p className="mt-1 text-sm text-red-600">{errors['rent_preferences.max_budget']}</p>}
              </div>

              <div>
                <label htmlFor="min_rent_duration_level_edit" className="block text-sm font-medium text-gray-700">
                  Min Rent Duration Level
                </label>
                <select
                  id="min_rent_duration_level_edit"
                  value={editFormState.rent_preferences.min_rent_duration_level} // Handle potential null
                  onChange={(e) => updateEditFormState('rent_preferences', 'min_rent_duration_level', Number(e.target.value))} // Send null if empty string
                  className={`mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm ${
                    errors['rent_preferences.min_rent_duration_level'] ? 'border-red-500' : ''
                  }`}
                >
                  <option value="1">Level 1</option>
                  <option value="2">Level 2</option>
                  <option value="3">Level 3</option>
                  <option value="4">Level 4</option>
                  <option value="5">Level 5</option>
                </select>
                {errors['rent_preferences.min_rent_duration_level'] && <p className="mt-1 text-sm text-red-600">{errors['rent_preferences.min_rent_duration_level']}</p>}
              </div>
              <div>
                <label htmlFor="max_rent_duration_level_edit" className="block text-sm font-medium text-gray-700">
                  Max Rent Duration Level
                </label>
                <select
                  id="max_rent_duration_level_edit"
                  value={editFormState.rent_preferences.max_rent_duration_level} // Handle potential null
                  onChange={(e) => updateEditFormState('rent_preferences', 'max_rent_duration_level', Number(e.target.value))} // Send null if empty string
                  className={`mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm ${
                    errors['rent_preferences.max_rent_duration_level'] ? 'border-red-500' : ''
                  }`}
                >
                  <option value="1">Level 1</option>
                  <option value="2">Level 2</option>
                  <option value="3">Level 3</option>
                  <option value="4">Level 4</option>
                  <option value="5">Level 5</option>
                </select>
                {errors['rent_preferences.max_rent_duration_level'] && <p className="mt-1 text-sm text-red-600">{errors['rent_preferences.max_rent_duration_level']}</p>}
              </div>
              <div>
                <label htmlFor="room_sharing_level_edit" className="block text-sm font-medium text-gray-700">
                  Room Sharing Level
                </label>
                <select
                  id="room_sharing_level_edit"
                  value={editFormState.rent_preferences.room_sharing_level ?? ''} // Handle potential null
                  onChange={(e) => updateEditFormState('rent_preferences', 'room_sharing_level', Number(e.target.value) as 1 | 2 | 3)} // Send null if empty string
                  className={`mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm ${
                    errors['rent_preferences.room_sharing_level'] ? 'border-red-500' : ''
                  }`}
                >
                  <option value="1">Private Room Only</option>
                  <option value="2">Shared Room Possible</option>
                  <option value="3">Flexible (Any Arrangement)</option>
                </select>
                {errors['rent_preferences.room_sharing_level'] && <p className="mt-1 text-sm text-red-600">{errors['rent_preferences.room_sharing_level']}</p>}
              </div>
            </div>
            {/* Location Search Component */}
            <div className="mt-4">
                <label className="block text-sm font-medium text-gray-700">
                  Locations (Select up to 30, no overlaps)
                </label>
                <Locations
                    // Pass the array of hierarchies from editFormState
                    selectedLocations={editFormState.rent_preferences.locations}
                    initialLocationNames={initialLocationNamesMap} // PASS THE NEW PROP
                    onLocationsChange={handleLocationsChange}
                    // Pass error state and handler
                    // Ensure the error prop is either a string or undefined, never null
                    error={errors['rent_preferences.locations'] || undefined} // CORRECT: Use '|| undefined' to guarantee 'string | undefined' type
                    onClearError={clearLocationsError}
                />
                {errors['rent_preferences.locations'] && <p className="mt-1 text-sm text-red-600">{errors['rent_preferences.locations']}</p>}
            </div>
          </div>

          {/* Other Details - Similar structure, add fields as needed */}
          <div className="mt-4 p-4 bg-gray-50 rounded-lg">
              <h3 className="text-lg font-medium text-gray-900 mb-2">Other Details</h3>
              <div className="grid grid-cols-2 gap-4">
                {/* Example: Neighbourliness Level */}
                <div>
                  <label htmlFor="neighbourliness_level_edit" className="block text-sm font-medium text-gray-700">
                    Neighbourliness Level
                  </label>
                  <select
                    id="neighbourliness_level_edit"
                    value={editFormState.about.neighbourliness_level ?? ''} // Handle potential null
                    onChange={(e) => updateEditFormState('about', 'neighbourliness_level', e.target.value ? Number(e.target.value) as 1 | 2 | 3 : null)} // Send null if empty string
                    className={`mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm ${
                      errors['about.neighbourliness_level'] ? 'border-red-500' : ''
                    }`}
                  >
                    <option value="">Select...</option>
                    <option value="1">Low</option>
                    <option value="2">Medium</option>
                    <option value="3">High</option>
                  </select>
                  {errors['about.neighbourliness_level'] && <p className="mt-1 text-sm text-red-600">{errors['about.neighbourliness_level']}</p>}
                </div>
                
                <div>
                  <label htmlFor="guests_level_edit" className="block text-sm font-medium text-gray-700">
                    Guests Level
                  </label>
                  <select
                    id="guests_level_edit"
                    value={editFormState.about.guests_level ?? ''} // Handle potential null
                    onChange={(e) => updateEditFormState('about', 'guests_level', e.target.value ? Number(e.target.value) as 1 | 2 | 3 : null)} // Send null if empty string
                    className={`mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm ${
                      errors['about.guests_level'] ? 'border-red-500' : ''
                    }`}
                  >
                    <option value="">Select...</option>
                    <option value="1">Low</option>
                    <option value="2">Medium</option>
                    <option value="3">High</option>
                  </select>
                  {errors['about.guests_level'] && <p className="mt-1 text-sm text-red-600">{errors['about.guests_level']}</p>}
                </div>
                <div>
                  <label htmlFor="parties_level_edit" className="block text-sm font-medium text-gray-700">
                    Parties Level
                  </label>
                  <select
                    id="parties_level_edit"
                    value={editFormState.about.parties_level ?? ''} // Handle potential null
                    onChange={(e) => updateEditFormState('about', 'parties_level', e.target.value ? Number(e.target.value) as 1 | 2 | 3 : null)} // Send null if empty string
                    className={`mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm ${
                      errors['about.parties_level'] ? 'border-red-500' : ''
                    }`}
                  >
                    <option value="">Select...</option>
                    <option value="1">Low</option>
                    <option value="2">Medium</option>
                    <option value="3">High</option>
                  </select>
                  {errors['about.parties_level'] && <p className="mt-1 text-sm text-red-600">{errors['about.parties_level']}</p>}
                </div>
                <div>
                  <label htmlFor="bedtime_level_edit" className="block text-sm font-medium text-gray-700">
                    Bedtime Level
                  </label>
                  <select
                    id="bedtime_level_edit"
                    value={editFormState.about.bedtime_level ?? ''} // Handle potential null
                    onChange={(e) => updateEditFormState('about', 'bedtime_level', e.target.value ? Number(e.target.value) as 1 | 2 | 3 | 4 : null)} // Send null if empty string, adjust type if needed
                    className={`mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm ${
                      errors['about.bedtime_level'] ? 'border-red-500' : ''
                    }`}
                  >
                    <option value="">Select...</option>
                    <option value="1">Early (e.g., 22:00)</option>
                    <option value="2">Midnight</option>
                    <option value="3">Late (e.g., 02:00)</option>
                    <option value="4">Very Late (e.g., 04:00)</option>
                  </select>
                  {errors['about.bedtime_level'] && <p className="mt-1 text-sm text-red-600">{errors['about.bedtime_level']}</p>}
                </div>
                <div>
                  <label htmlFor="neatness_level_edit" className="block text-sm font-medium text-gray-700">
                    Neatness Level
                  </label>
                  <select
                    id="neatness_level_edit"
                    value={editFormState.about.neatness_level ?? ''} // Handle potential null
                    onChange={(e) => updateEditFormState('about', 'neatness_level', e.target.value ? Number(e.target.value) as 1 | 2 | 3 : null)} // Send null if empty string
                    className={`mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm ${
                      errors['about.neatness_level'] ? 'border-red-500' : ''
                    }`}
                  >
                    <option value="">Select...</option>
                    <option value="1">Low</option>
                    <option value="2">Medium</option>
                    <option value="3">High</option>
                  </select>
                  {errors['about.neatness_level'] && <p className="mt-1 text-sm text-red-600">{errors['about.neatness_level']}</p>}
                </div>

                {/* Pet Checkboxes */}
                <div className="col-start-1 col-span-2">
                  <p className="text-sm font-medium text-gray-700 mb-1">I Have Animals:</p> {/* Label for the group */}
                  <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-4 gap-4">
                      <div className="flex items-center">
                        <input
                          id="has_cats_edit"
                          type="checkbox"
                          checked={editFormState.about.has_cats === true}
                          onChange={(e) => updateEditFormState('about', 'has_cats', e.target.checked)}
                          className="h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500"
                        />
                        <label htmlFor="has_cats_edit" className="ml-2 block text-sm text-gray-700">
                          Cats
                        </label>
                      </div>
                      <div className="flex items-center">
                        <input
                          id="has_dogs_edit"
                          type="checkbox"
                          checked={editFormState.about.has_dogs === true}
                          onChange={(e) => updateEditFormState('about', 'has_dogs', e.target.checked)}
                          className="h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500"
                        />
                        <label htmlFor="has_dogs_edit" className="ml-2 block text-sm text-gray-700">
                          Dogs
                        </label>
                      </div>
                      <div className="flex items-center">
                        <input
                          id="has_reptiles_edit"
                          type="checkbox"
                          checked={editFormState.about.has_reptiles === true}
                          onChange={(e) => updateEditFormState('about', 'has_reptiles', e.target.checked)}
                          className="h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500"
                        />
                        <label htmlFor="has_reptiles_edit" className="ml-2 block text-sm text-gray-700">
                          Reptiles
                        </label>
                      </div>
                      <div className="flex items-center">
                        <input
                          id="has_birds_edit"
                          type="checkbox"
                          checked={editFormState.about.has_birds === true}
                          onChange={(e) => updateEditFormState('about', 'has_birds', e.target.checked)}
                          className="h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500"
                        />
                        <label htmlFor="has_birds_edit" className="ml-2 block text-sm text-gray-700">
                          Birds
                        </label>
                      </div>
                    </div>
                  </div>
                  {/* other_animals (TagsInput or similar) */}
                  <div className="col-span-2">
                    <label htmlFor="other_animals_edit" className="block text-sm font-medium text-gray-700">
                      Other Animals (up to 5)
                    </label>
                    <TagsInput
                      isEditOnRemove
                      value={editFormState.about.other_animals} // Bind to editFormState
                      beforeAddValidate={(newTag: string, currentTags: string[]) => {
                        const newTagsCandidate = [...currentTags, newTag];
                        const validationError = validators['about.other_animals'](newTagsCandidate, editFormState); // Use editFormState

                        // Update the main errors state if validation fails
                        if (validationError !== null) {
                          setErrors(prevErrors => ({
                            ...prevErrors,
                            'about.other_animals': validationError
                          }));
                          return false; // Prevent adding the tag
                        }

                        // Clear the specific error for this field if validation passes
                        setErrors(prevErrors => {
                          const newErrors = { ...prevErrors };
                          delete newErrors['about.other_animals']; // Remove the error for this key
                          return newErrors;
                        });
                        return true; // Allow adding the tag
                      }}
                      onChange={(tags) => {
                          // Clear the specific error for this field whenever tags change
                          // This happens after a successful add (when beforeAddValidate passed)
                          // or a remove action.
                          setErrors(prevErrors => {
                            const newErrors = { ...prevErrors };
                            delete newErrors['about.other_animals']; // Remove the error for this key
                            return newErrors;
                          });
                          updateEditFormState('about', 'other_animals', tags); // Use updateEditFormState
                        }}
                      onKeyUp={(e: React.KeyboardEvent<HTMLInputElement>) => {
                          const inputValue = (e.target as HTMLInputElement).value;

                          if (inputValue) {
                            const currentTags = editFormState.about.other_animals || []; // Use editFormState
                            const newTagsCandidate = [...currentTags, inputValue];
                            validateCurrentTagsInput('about.other_animals', newTagsCandidate, 'about.other_animals'); // Use helper
                          }
                          else {
                            const currentTags = editFormState.about.other_animals || [];
                            validateCurrentTagsInput('about.other_animals', currentTags, 'about.other_animals'); // Use helper
                          }
                        }}
                      onBlur={(e: React.FocusEvent<HTMLInputElement>) => {
                          const inputElement = e.target as HTMLInputElement
                          const inputValue = inputElement.value
                          if (inputValue) {
                            inputElement.value = '' // Clear the input field if it had an error and was blurred while containing text
                            setErrors(prevErrors => {
                              const newErrors = { ...prevErrors };
                              delete newErrors['about.other_animals']; // Remove the error for this key
                              return newErrors;
                            })
                          }
                        }}
                      name="other_animals_edit" // Unique name for this instance
                      placeHolder="Type and press enter"
                      // Adapted Tailwind classes for styling, matching the pattern from ProfileSetupPage and other inputs in ProfileEditView
                      classNames={{
                        tag: "bg-blue-100 text-blue-800 px-2 py-1 rounded-md text-sm", // Style for individual tags
                        input: "mt-0 block w-full p-0 text-sm border-0 focus:outline-none focus:ring-0", // Style for the input field itself, removing default border/ring to inherit from parent
                        // The parent div provides the border, focus ring, and error styling
                      }}
                    />
                    {/* Error display using the standard pattern for this component */}
                    {errors['about.other_animals'] && <p className="mt-1 text-sm text-red-600">{errors['about.other_animals']}</p>}
                  </div>

                  <div className="col-span-2">
                    <label htmlFor="interests_edit" className="block text-sm font-medium text-gray-700">
                      Interests (up to 5)
                    </label>
                    <TagsInput
                      isEditOnRemove
                      value={editFormState.about.interests || []} // Bind to editFormState
                      beforeAddValidate={(newTag: string, currentTags: string[]) => {
                          const newTagsCandidate = [...currentTags, newTag];
                          const validationError = validators['about.interests'](newTagsCandidate, editFormState); // Use editFormState

                          // Update the main errors state if validation fails
                          if (validationError !== null) {
                            setErrors(prevErrors => ({
                              ...prevErrors,
                              'about.interests': validationError
                            }));
                            return false; // Prevent adding the tag
                          }

                          // Clear the specific error for this field if validation passes
                          setErrors(prevErrors => {
                            const newErrors = { ...prevErrors };
                            delete newErrors['about.interests']; // Remove the error for this key
                            return newErrors;
                          });
                          return true; // Allow adding the tag
                        }}
                      onChange={(tags) => {
                          setErrors(prevErrors => {
                            const newErrors = { ...prevErrors };
                            delete newErrors['about.interests']; // Remove the error for this key
                            return newErrors;
                          });
                          updateEditFormState('about', 'interests', tags); // Use updateEditFormState
                        }}
                      onKeyUp={(e: React.KeyboardEvent<HTMLInputElement>) => {
                          const inputValue = (e.target as HTMLInputElement).value;

                          if (inputValue) {
                            const currentTags = editFormState.about.interests || []; // Use editFormState
                            const newTagsCandidate = [...currentTags, inputValue];
                            validateCurrentTagsInput('about.interests', newTagsCandidate, 'about.interests'); // Use helper
                          }
                          else {
                            const currentTags = editFormState.about.interests || [];
                            validateCurrentTagsInput('about.interests', currentTags, 'about.interests'); // Use helper
                          }
                        }}
                      onBlur={(e: React.FocusEvent<HTMLInputElement>) => {
                          const inputElement = e.target as HTMLInputElement
                          const inputValue = inputElement.value
                          if (inputValue) {
                            inputElement.value = '' // Clear the input field if it had an error and was blurred while containing text
                            setErrors(prevErrors => {
                              const newErrors = { ...prevErrors };
                              delete newErrors['about.interests']; // Remove the error for this key
                              return newErrors;
                            })
                          }
                        }}
                      name="interests_edit" // Unique name for this instance
                      placeHolder="Type and press enter"
                      // Adapted Tailwind classes for styling
                      classNames={{
                        tag: "bg-blue-100 text-blue-800 px-2 py-1 rounded-md text-sm",
                        input: "mt-0 block w-full p-0 text-sm border-0 focus:outline-none focus:ring-0",
                      }}
                    />
                    {/* Error display */}
                    {errors['about.interests'] && <p className="mt-1 text-sm text-red-600">{errors['about.interests']}</p>}
                  </div>

                  {/* bio (textarea) */}
                  <div className="col-span-2">
                    <label htmlFor="bio_edit" className="block text-sm font-medium text-gray-700">
                      Bio (up to 1024 chars)
                    </label>
                    <textarea
                      id="bio_edit"
                      rows={3}
                      value={editFormState.about.bio ?? ''} // Handle potential null
                      onChange={(e) => updateEditFormState('about', 'bio', e.target.value || null)} // Send null if empty string
                      className={`mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm ${
                        errors['about.bio'] ? 'border-red-500' : ''
                      }`}
                    />
                    <p className={`text-xs mt-1 ${
                      editFormState.about.bio && editFormState.about.bio.length > 1024 ? 'text-red-600' : 'text-gray-500' // Change color based on limit
                    }`}>
                      {editFormState.about.bio ? editFormState.about.bio.length : 0} / 1024 characters
                    </p>
                    {errors['about.bio'] && <p className="mt-1 text-sm text-red-600">{errors['about.bio']}</p>}
                  </div>
              </div>
            </div>
        </div>
      </div>

      {/* Save/Cancel Buttons */}
      <div className="flex justify-end space-x-4 mt-6">
        <button
          type="button"
          onClick={onCancel} // Call the cancel callback
          disabled={isSaving}
          className={`px-4 py-2 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 ${
            isSaving ? 'opacity-50 cursor-not-allowed' : ''
          }`}
        >
          Cancel
        </button>
        <button
          type="button"
          onClick={handleSave}
          disabled={!hasChanges || isSaving} // Disable if no changes OR if currently saving
          className={`px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white ${
            !hasChanges || isSaving // Condition for disabled state
              ? 'bg-gray-400 cursor-not-allowed' // Styles when disabled
              : 'bg-green-600 hover:bg-green-700' // Styles when enabled
          } focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500`}
        >
          {isSaving ? 'Saving...' : 'Save Changes'} {/* Button text can indicate saving */}
        </button>
      </div>
    </div>
  )
}

_____________________________

shallwe_frontend/src/app/components/profile/ProfilePhotoPick.tsx:

import React, { useState, useCallback, useRef, useEffect, useMemo } from 'react'

import Cropper, { Area, Point } from 'react-easy-crop' // Import Cropper and required types, remove Size if not needed elsewhere

import { ApiError } from '@/lib/shallwe/common/api/calls' // Import ApiError type
import { performFacecheck } from '@/lib/shallwe/photo/api/calls' // Import the facecheck API call
import { validateProfilePhotoFile } from '@/lib/shallwe/photo/formstates/validators' // Import THE specific validator
import PhotoWithFallbacks from './PhotoWithFallbacks'


type Crop = Point // Type alias for {x, y} point
type Zoom = number


interface ProfilePhotoPickProps {
  initialFile?: File | null
  initialPhotoUrl?: string | null
  onError: (error: string) => void
  onClearError: () => void
  onCropComplete: (croppedFile: File) => void
}


const ProfilePhotoPick: React.FC<ProfilePhotoPickProps> = ({ 
  initialFile, 
  initialPhotoUrl,
  onError, 
  onClearError, 
  onCropComplete,
}) => {
  
  const [imageSrc, setImageSrc] = useState<string | null>(null); // Source for the image to crop (from new file)
  const [displayImageUrl, setDisplayImageUrl] = useState<string | null>(null); // URL for displaying existing photo
  const [crop, setCrop] = useState<Crop>({ x: 0, y: 0 });
  const [zoom, setZoom] = useState<Zoom>(1);
  const [croppedAreaPixels, setCroppedAreaPixels] = useState<Area | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [selectedRawFile, setSelectedRawFile] = useState<File | null>(null);
  const [finalCroppedFile, setFinalCroppedFile] = useState<File | null>(null);
  const [committedCroppedFile, setCommittedCroppedFile] = useState<File | null>(null);
  const fileInputRef = useRef<HTMLInputElement>(null);


  // --- EFFECT 1: Handle changes to initialFile (new file selected) ---
  // This effect prioritizes a newly selected file for cropping/preview
  useEffect(() => {
    if (initialFile instanceof File) {
      console.log("ProfilePhoto: New initialFile provided, preparing for cropping.");
      // A new file is provided (e.g., from parent state after user selection)
      setSelectedRawFile(initialFile);
      setFinalCroppedFile(null); // Clear any previous final cropped file
      const reader = new FileReader();
      reader.onload = () => {
        setImageSrc(reader.result as string); // Set imageSrc to trigger cropper UI
        setDisplayImageUrl(null); // Ensure display URL is cleared if showing cropper
        // Reset crop/zoom for new image
        setCrop({ x: 0, y: 0 });
        setZoom(1);
      };
      reader.onerror = () => {
        console.error("ProfilePhoto: Error reading initialFile.");
        onError("Failed to load the selected image.");
        setImageSrc(null);
        setDisplayImageUrl(null);
      };
      reader.readAsDataURL(initialFile);
    } else if (initialFile === null) {
      // Explicitly cleared by parent (e.g., onClear or successful save leading to reset)
      console.log("ProfilePhoto: initialFile cleared.");
      handleClearInternals(); // Reset internal state
    }
    // Note: Does not handle initialFile being a string URL here, that's initialPhotoUrl's job.
  }, [initialFile]); // Only re-run if initialFile prop changes

  // --- EFFECT 2: Handle changes to initialPhotoUrl (existing photo URL) ---
  // This effect sets the display URL when no new file is being processed.
  useEffect(() => {
    if (initialPhotoUrl && typeof initialPhotoUrl === 'string') {
      // An initial photo URL is provided (e.g., existing profile photo)
      console.log("ProfilePhoto: initialPhotoUrl provided.");
      // Only set display URL if there's no new file selected/cropped currently
      if (!selectedRawFile && !finalCroppedFile && !imageSrc) {
        setDisplayImageUrl(initialPhotoUrl);
      }
      // If a new file is selected (imageSrc/finalCroppedFile set), this URL is ignored visually.
    } else if (initialPhotoUrl === null || initialPhotoUrl === '') {
      // URL explicitly cleared or invalid
      console.log("ProfilePhoto: initialPhotoUrl cleared or invalid.");
      // Only clear display URL if no new file is actively being processed
      if (!selectedRawFile && !finalCroppedFile && !imageSrc) {
        setDisplayImageUrl(null);
      }
    }
  }, [initialPhotoUrl, selectedRawFile, finalCroppedFile, imageSrc]); // Re-run if URL or processing state changes

  // --- HELPER: Clear internal state without triggering prop changes ---
  const handleClearInternals = () => {
    setImageSrc(null);
    setDisplayImageUrl(null);
    setCrop({ x: 0, y: 0 });
    setZoom(1);
    setCroppedAreaPixels(null);
    setSelectedRawFile(null);
    setFinalCroppedFile(null);
    if (fileInputRef.current) {
      fileInputRef.current.value = ''; // Reset native file input
    }
    // Do NOT call onClearError here automatically, let parent decide.
    };

  // Clear state when initialFile changes (e.g., cleared by parent)
  useEffect(() => {
     if (initialFile === null) {
         handleClear()
     }
  }, [initialFile])

  // Handle file selection
  const onFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    if (e.target.files && e.target.files.length > 0) {
      const file = e.target.files[0]
      // Clear previous error and state when a new file is selected
      onClearError()
      setSelectedRawFile(file)
      setFinalCroppedFile(null) // Clear final file as we are starting over
      setImageSrc(null) // Clear preview initially

      // --- RUN THE SPECIFIC VALIDATOR FOR THE RAW FILE ---
      // Pass the raw file directly to the dedicated validator
      const fieldError = validateProfilePhotoFile(file) // Call the specific validator

      if (fieldError) {
          // Validator failed for the raw file
          onError(fieldError)
          setSelectedRawFile(null) // Reset the internal state
          // Do not proceed to load the image
          return
      }

      // Validator passed for the raw file, proceed to load preview
      const reader = new FileReader()
      reader.onload = () => {
        if (fileInputRef.current) {
            fileInputRef.current.value = '';
        }
        setImageSrc(reader.result as string)
        // Reset crop position when a new image is loaded
        setCrop({ x: 0, y: 0 })
        setZoom(1) // Reset zoom when a new image is loaded
        // Clear any previous errors related to the photo now that a valid raw file is selected
        onClearError()
      }
      reader.readAsDataURL(file)
    }
  }

  // Handle crop change (position) - This function is passed to the Cropper component
  const onCropChange = (newCrop: Crop) => {
    setCrop(newCrop)
  }

  // Handle zoom change - This function is passed to the Cropper component
  const onZoomChange = (newZoom: Zoom) => {
    setZoom(newZoom)
  }

  // Handle area selection change (when user moves/zooms the crop area) - This function is passed to the Cropper component
  const onCropCompleteHandler = useCallback((croppedArea: Area, newCroppedAreaPixels: Area) => {
    // setCroppedAreaPixels is called with the new pixels
    setCroppedAreaPixels(newCroppedAreaPixels)
  }, []) // No dependencies needed for this callback if setCroppedAreaPixels is stable


  // Crop the image using canvas
  const getCroppedImg = useCallback(async (): Promise<Blob | null> => {
    if (!imageSrc || !croppedAreaPixels) {
      console.error("Cannot crop: imageSrc or croppedAreaPixels is missing")
      return null
    }

    const image = new Image()
    image.src = imageSrc
    await new Promise((resolve) => {
      image.onload = resolve
    })

    const canvas = document.createElement('canvas')
    const ctx = canvas.getContext('2d')

    if (!ctx) {
      console.error('Canvas context not available')
      return null
    }

    // Set canvas size to the cropped area size
    canvas.width = croppedAreaPixels.width
    canvas.height = croppedAreaPixels.height

    // Draw the cropped portion of the image onto the canvas
    ctx.drawImage(
      image,
      croppedAreaPixels.x,
      croppedAreaPixels.y,
      croppedAreaPixels.width,
      croppedAreaPixels.height,
      0,
      0,
      croppedAreaPixels.width,
      croppedAreaPixels.height
    )

    return new Promise((resolve) => {
      canvas.toBlob(resolve, selectedRawFile?.type || 'image/jpeg') // Use original file type if possible
    })
  }, [imageSrc, croppedAreaPixels, selectedRawFile?.type])

  const finalCroppedFileUrl = useMemo(() => {
    console.log("ProfilePhoto: Recalculating finalCroppedFileUrl");
    return finalCroppedFile ? URL.createObjectURL(finalCroppedFile) : null;
  }, [finalCroppedFile]); // Only recalculate if finalCroppedFile object reference changes

  // Handle Apply button click
  const handleApply = async () => {
    if (!selectedRawFile || !croppedAreaPixels) {
      onError('No image selected or crop area defined.')
      return
    }

    setIsLoading(true)
    try {
      // Get the cropped image blob
      const croppedBlob = await getCroppedImg()
      if (!croppedBlob) {
        throw new Error('Failed to crop image.')
      }

      // Convert blob to file - this is the final file that will be validated and sent
      const croppedFile = new File([croppedBlob], selectedRawFile.name, { type: selectedRawFile.type })

      // Perform facecheck API call with the cropped file
      const facecheckResult = await performFacecheck(croppedFile)

      // Check the result of the facecheck API call
      if (facecheckResult.success) {
        setFinalCroppedFile(croppedFile)
        setCommittedCroppedFile(croppedFile) // <-- NEW: remember the last valid crop
        onCropComplete(croppedFile)
        onClearError()
      } else {
        onError(facecheckResult.error || 'Facecheck failed. Please ensure your photo contains a clear face.')
        setFinalCroppedFile(null)
      }
    } catch (error) {
      console.error('Error during facecheck:', error)
      // Handle API errors (e.g., network issues, 400 bad request from facecheck)
      let errorMessage = 'An error occurred during photo validation.'
      if (error && typeof error === 'object' && 'details' in error) {
          const apiError = error as ApiError
          if (apiError.details && typeof apiError.details === 'object' && 'error' in apiError.details) {
              const apiErrorMsg = apiError.details.error
              errorMessage = typeof apiErrorMsg === 'string' ? apiErrorMsg : JSON.stringify(apiErrorMsg)
          } else if (apiError.message) {
              errorMessage = apiError.message
          }
      } else if (error instanceof Error) {
          errorMessage = error.message
      }
      onError(errorMessage)
      setFinalCroppedFile(null) // Clear the final file state as it's invalid
    } finally {
      setIsLoading(false)
    }
  }

  // Clear the current image and reset state
  const handleClear = () => {
    setImageSrc(null)
    setCrop({ x: 0, y: 0 })
    setZoom(1)
    setCroppedAreaPixels(null)
    setSelectedRawFile(null)
    // setFinalCroppedFile(null)
    if (committedCroppedFile) {
      setFinalCroppedFile(committedCroppedFile)
    } 
    if (fileInputRef.current) {
      fileInputRef.current.value = '' // Reset file input
    }
    onClearError() // Clear any errors associated with the previous image
  }

  // Load initial file preview if provided (only if it passes initial validation conceptually,
  // but we don't re-validate here unless initialFile changes)
  useEffect(() => {
    if (initialFile) {
      // Assume initialFile passed validation when it was set in the parent state
      // Just load the preview for the initial file
      setSelectedRawFile(initialFile)
      setFinalCroppedFile(initialFile) // If initialFile is the *final* cropped one from a previous save/edit
      const reader = new FileReader()
      reader.onload = () => {
        setImageSrc(reader.result as string)
      }
      reader.readAsDataURL(initialFile)
    } else {
      // If initialFile is null/undefined, clear the state
      handleClear()
    }
  }, [initialFile]) // Only run on initialFile change, not on other state changes


  return (
    <div className="space-y-4">
      <div>
        <label className="block text-sm font-medium text-gray-700">
          Photo (JPG, PNG, HEIC, HEIF, max 20MB, will be cropped to square)
        </label>

        {/* hidden file input */}
        <input
          ref={fileInputRef}
          type="file"
          accept="image/jpeg,image/jpg,image/png,image/heic,image/heif"
          onChange={onFileChange}
          className="hidden"
        />

        {/* custom trigger button */}
        <button
          type="button"
          onClick={() => fileInputRef.current?.click()}
          className="mt-1 inline-flex items-center rounded-md bg-blue-50 px-4 py-2 text-sm font-semibold text-blue-700 shadow-sm hover:bg-blue-100 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-blue-500"
        >
          Choose File
        </button>
      </div>

      {/* Preview Area - Shows raw file preview, cropped preview, or placeholder */}
      <div className="relative w-full h-64 md:h-80 bg-gray-100 rounded-md overflow-hidden border border-gray-300">
        {imageSrc && !finalCroppedFile && ( // Show cropper if new raw file is loaded but not yet validated/applied
          <>
            <Cropper
              image={imageSrc}
              crop={crop}
              zoom={zoom}
              aspect={1}
              onCropChange={onCropChange}
              onZoomChange={onZoomChange}
              onCropComplete={onCropCompleteHandler} // Make sure this handler updates croppedAreaPixels
              showGrid={true}
            />
          </>
        )}
        {finalCroppedFile && ( // Show final cropped file preview if available (after successful apply)
          <PhotoWithFallbacks
            src={finalCroppedFileUrl!}
            alt="Cropped preview"
            className="w-full h-full object-contain"
          />
        )}
        {!imageSrc && !finalCroppedFile && displayImageUrl && ( // Show existing photo URL if available and no new file is being processed
          <PhotoWithFallbacks
            src={displayImageUrl}
            alt="Existing profile photo"
            className="w-full h-full object-contain" // Pass Tailwind classes
          />
        )}
        {!imageSrc && !finalCroppedFile && !displayImageUrl && ( // Show placeholder if nothing to display
          <div className="w-full h-full flex items-center justify-center">
            <p className="text-gray-400 text-sm">Select a photo to begin</p>
          </div>
        )}
      </div>

      {/* Controls appear after raw file is loaded and validated */}
      {imageSrc && !finalCroppedFile && ( // Show controls if raw file is loaded but not yet cropped/validated
        <div className="flex flex-col space-y-2">
          <div className="flex items-center space-x-2">
            <label htmlFor="zoom" className="text-sm font-medium text-gray-700">
              Zoom:
            </label>
            <input
              id="zoom"
              type="range"
              min={1}
              max={3}
              step={0.1}
              value={zoom}
              onChange={(e) => onZoomChange(parseFloat(e.target.value))}
              className="w-full max-w-xs"
            />
            <span className="text-sm text-gray-500">{zoom.toFixed(2)}x</span>
          </div>

          <div className="flex space-x-2">
            <button
              type="button"
              onClick={handleApply}
              disabled={isLoading}
              className={`px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white ${
                isLoading ? 'bg-gray-400' : 'bg-indigo-600 hover:bg-indigo-700'
              } focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500`}
            >
              {isLoading ? 'Validating...' : 'Apply & Validate'}
            </button>
            <button
              type="button"
              onClick={handleClear}
              className="px-4 py-2 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
            >
              Clear
            </button>
          </div>
        </div>
      )}

      {/* Show final cropped file name after successful cropping/validation */}
      {finalCroppedFile && (
        <div className="mt-2">
          <p className="text-xs text-gray-500">Selected: {finalCroppedFile.name}</p>
        </div>
      )}
    </div>
  )
}

export default ProfilePhotoPick

_____________________________

shallwe_frontend/src/app/settings/page.tsx:

'use client'


import { useState, useEffect } from 'react'
import { useRouter } from 'next/navigation'

import { getProfile, updateProfileVisibility } from '@/lib/shallwe/profile/api/calls' // Import read and visibility API calls
import { deleteUser } from '@/lib/shallwe/auth/api/calls' // Import delete API call
import { ProfileReadData } from '@/lib/shallwe/profile/api/schema/read' // Import the read data type
import { ApiError } from '@/lib/shallwe/common/api/calls' // Import ApiError type
import { ProfileEditView } from '../components/profile/ProfileEditView'
import PhotoWithFallbacks from '../components/profile/PhotoWithFallbacks'
import { LocationsReadFields } from '@/lib/shallwe/locations/api/schema'


interface DisplayLocation {
  type: 'region' | 'city' | 'district' | 'other_ppl';
  displayName: string;
}


export const prepareLocationsForDisplay = (locationsObject: LocationsReadFields): DisplayLocation[] => {
  const displayItems: DisplayLocation[] = [];

  // Process Regions
  if (locationsObject.regions) {
    locationsObject.regions.forEach(region => {
      displayItems.push({
        type: 'region',
        displayName: region.region_name,
      });
    });
  }

  // Process Cities and their Districts (applying the rule)
  if (locationsObject.cities) {
    locationsObject.cities.forEach(city => {
      const districtHierarchies = city.districts || [];
      if (districtHierarchies.length > 0) {
        // Rule: If city has districts, add only the districts
        districtHierarchies.forEach(district => {
          displayItems.push({
            type: 'district',
            displayName: `${city.ppl_name}, ${district.district_name}`, // e.g., "Kyiv, Holosiivskyi"
          });
        });
      } else {
        // Rule: If city has no districts, add the city
        displayItems.push({
          type: 'city',
          displayName: `${city.ppl_name} (${city.region_name})`, // e.g., "Lviv (Lvivska)"
        });
      }
    });
  }

  // Process Other PPLs
  if (locationsObject.other_ppls) {
    locationsObject.other_ppls.forEach(otherPpl => {
      const suffix = otherPpl.subregion_name
        ? `${otherPpl.region_name}, ${otherPpl.subregion_name}`
        : otherPpl.region_name;
      displayItems.push({
        type: 'other_ppl',
        displayName: `${otherPpl.ppl_name} (${suffix})`, // e.g., "Yasno (Ivano-Frankivska, Nizhynskyi)"
      });
    });
  }

  return displayItems;
};


export default function SettingsPage() {

  const [profileData, setProfileData] = useState<ProfileReadData | null>(null)
  const [isLoading, setIsLoading] = useState(true) // Add loading state
  const [isVisibilityUpdating, setIsVisibilityUpdating] = useState(false)
  const [isDeleteModalOpen, setIsDeleteModalOpen] = useState(false)
  const [isDeleting, setIsDeleting] = useState(false)
  const [apiError, setApiError] = useState<string | null>(null)
  const [isEditing, setIsEditing] = useState(false)
  const router = useRouter()

  const formatSmokingTypes = (smokesIqos: boolean | null, smokesVape: boolean | null, smokesTobacco: boolean | null, smokesCigs: boolean | null): string => {
    const types: string[] = [];
    if (smokesIqos) types.push('IQOS');
    if (smokesVape) types.push('Vape');
    if (smokesTobacco) types.push('Tobacco');
    if (smokesCigs) types.push('Cigarettes');
    return types.join(', ');
  }

  const handleEditClick = () => {
    setIsEditing(true)
    setApiError(null) // Clear any previous errors when starting edit
  }

  const handleEditSave = () => {
    setIsEditing(false) // Set isEditing back to false on successful save
    fetchProfile()
  }

  const handleEditCancel = () => {
    setIsEditing(false) // Set isEditing back to false on cancel
    setApiError(null) // Clear any errors set during editing
  }

  const fetchProfile = async () => {
    try {
      setIsLoading(true) // Set loading state
      setApiError(null) // Clear previous errors
      const data = await getProfile()
      setProfileData(data)
      console.log("Profile data fetched successfully:", data)
    } catch (error) {
      console.error("Error fetching profile in SettingsPage client component:", error)
      // Handle potential 404 (profile not found) or 403 (unauthorized) from getProfile
      // If API returns 403/404, redirect to setup or landing.
      // Let's assume getProfile throws an error object compatible with ApiError.
      if (error && typeof error === 'object' && 'details' in error) {
        const err = error as ApiError
        // Check if it's a 403 or 404 error from the API call
        // This requires checking the response status within the error object,
        // which baseApiCall should provide.
        // Example: if (err.details.status === 404 || err.details.status === 403) { ... }
        // For now, just set the error message.
        let errorMessage = "Failed to load profile."
        if (typeof err.details === 'string') {
            errorMessage = err.details
        } else if (typeof err.details === 'object' && err.details && 'error' in err.details) {
            errorMessage = JSON.stringify(err.details.error)
        } else if (err.details && 'status' in err.details) {
            // Assuming err.details contains the response object or status
            if (err.details.status === 404 || err.details.status === 403) {
                // Redirect to setup or landing if profile not found/unauthorized
                // This mimics the server-side redirect logic
                console.log("Profile not found or unauthorized, redirecting...")
                router.push('/') // Redirect to landing as a safe fallback
                return // Exit useEffect after redirect
            }
        }
        setApiError(errorMessage)
      } else if (error instanceof Error) {
        setApiError(error.message)
      } else {
        setApiError("An unexpected error occurred while loading your profile.")
      }
    } finally {
      setIsLoading(false) // Clear loading state
    }
  }

  // Fetch profile data on component mount
  useEffect(() => {
    fetchProfile()
  }, [router]) // Add router to dependency array if used for redirect

  const handleToggleVisibility = async () => {
    if (isVisibilityUpdating || !profileData) return // Prevent calls if updating or data not loaded

    setIsVisibilityUpdating(true)
    setApiError(null)
    const newIsHidden = !profileData.profile.is_hidden

    try {
      await updateProfileVisibility(newIsHidden)
      // Update local state optimistically
      setProfileData(prev => prev ? {
        ...prev,
        profile: { ...prev.profile, is_hidden: newIsHidden }
      } : null)
      console.log(`Profile visibility updated to: ${newIsHidden ? 'Hidden' : 'Visible'}`)
    } catch (error) {
      console.error("Error updating profile visibility:", error)
      let errorMessage = "Failed to update profile visibility."
      if (error && typeof error === 'object' && 'details' in error) {
        const err = error as ApiError
        if (typeof err.details === 'string') {
            errorMessage = err.details
        } else if (typeof err.details === 'object' && err.details && 'error' in err.details) {
            errorMessage = JSON.stringify(err.details.error)
        }
      } else if (error instanceof Error) {
        errorMessage = error.message
      }
      setApiError(errorMessage)
    } finally {
      setIsVisibilityUpdating(false)
    }
  }

  const handleDeleteConfirm = async () => {
    if (isDeleting) return

    setIsDeleting(true)
    setApiError(null)

    try {
      await deleteUser()
      console.log("Profile and user deleted successfully!")
      // Redirect to landing page after successful deletion
      router.push('/')
      // router.refresh() // Optional: Refresh might not be needed after push
    } catch (error) {
      console.error("Error deleting user:", error)
      setIsDeleting(false)
      let errorMessage = "Failed to delete user."
      if (error && typeof error === 'object' && 'details' in error) {
        const err = error as ApiError
        if (typeof err.details === 'string') {
            errorMessage = err.details
        } else if (typeof err.details === 'object' && err.details && 'error' in err.details) {
            errorMessage = JSON.stringify(err.details.error)
        }
      } else if (error instanceof Error) {
        errorMessage = error.message
      }
      setApiError(errorMessage)
    }
  }

  // --- HELPER FUNCTIONS (Copied from ProfileReadView) ---
  const formatBoolean = (value: boolean): string => (value ? 'Yes' : 'No')

  const formatLevel = (value: number | null, type: 'drinking' | 'smoking' | 'neighbourliness' | 'guests' | 'parties' | 'bedtime' | 'neatness' | 'duration' | 'room_sharing'): string => {
    if (value === null) return 'Not specified'
    const labels: Record<string, string[]> = {
      drinking: ['Never', 'Rarely', 'Socially', 'Often'],
      smoking: ['Never', 'Rarely', 'Socially', 'Often'],
      neighbourliness: ['Low', 'Medium', 'High'],
      guests: ['Low', 'Medium', 'High'],
      parties: ['Low', 'Medium', 'High'],
      bedtime: ['Early (e.g., 22:00)', 'Midnight', 'Late (e.g., 02:00)', 'Very Late (e.g., 04:00)'],
      neatness: ['Low', 'Medium', 'High'],
      duration: ['1 month', '2 months', '3 months', '6 months', '1 year'],
      room_sharing: ['Private Room Only', 'Shared Room Possible', 'Flexible (Any Arrangement)'],
    }
    const typeLabels = labels[type]
    if (typeLabels && value >= 1 && value <= typeLabels.length) {
      return typeLabels[value - 1]
    }
    return `Level ${value}`
  }

  const formatOccupation = (value: number | null): string => {
    if (value === null) return 'Not specified'
    const labels: Record<number, string> = { 1: 'Employed', 2: 'Student', 3: 'Unemployed', 4: 'Retired' }
    return labels[value] || `Type ${value}`
  }

  const formatGender = (value: number | null): string => {
    if (value === null) return 'Not specified'
    const labels: Record<number, string> = { 1: 'Male', 2: 'Female' }
    return labels[value] || `Gender ${value}`
  }

  const joinArray = (items: string[] | undefined): string => {
    return items ? items.join(', ') : 'None'
  }
  // --- END HELPER FUNCTIONS ---

  // --- RENDER LOGIC ---
  if (isLoading) {
    return (
      <div className="min-h-screen bg-gradient-to-br from-background-white to-primary-blue flex items-center justify-center p-4">
        <div className="text-center">
          <p className="text-lg text-gray-700">Loading your profile...</p>
        </div>
      </div>
    )
  }

  if (!profileData) {
    // This state should ideally be handled by the error check in useEffect leading to a redirect,
    // but render a message just in case.
    return (
      <div className="min-h-screen bg-gradient-to-br from-background-white to-primary-blue flex flex-col items-center justify-center p-4">
        <div className="max-w-md w-full bg-white rounded-xl shadow-md p-8 space-y-6">
          <h1 className="text-2xl font-bold text-center text-black">Profile Not Found</h1>
          <p className="text-center text-gray-600">We couldn't load your profile data.</p>
          {apiError && <p className="text-center text-red-600">{apiError}</p>}
          <button
            onClick={() => router.push('/')} // Fallback redirect button
            className="w-full px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
          >
            Go to Home
          </button>
        </div>
      </div>
    )
  }

  // --- MAIN RENDER (Profile Data Loaded) ---
  return (
    <div className="min-h-screen bg-gradient-to-br from-background-white to-primary-blue flex flex-col items-center justify-center p-4">
      <div className="max-w-4xl w-full bg-white rounded-xl shadow-md p-8 space-y-6">
        <div className="flex justify-between items-start">
          <h1 className="text-2xl font-bold text-black">Your Profile Settings</h1>
          {/* Show Edit button only when not editing */}
          {!isEditing && (
              <button
                  onClick={handleEditClick}
                  className="ml-3 px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
              >
                  Edit
              </button>
          )}
        </div>

        {/* API Error Display */}
        {apiError && (
          <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded relative" role="alert">
            <span className="block sm:inline">Error: {apiError}</span>
          </div>
        )}

        {/* Profile Visibility Toggle */}
        <div className="flex items-center justify-between p-4 bg-gray-50 rounded-lg">
          <span className="text-sm font-medium text-gray-700">
            Profile Visibility: <strong>{profileData.profile.is_hidden ? 'Hidden' : 'Visible'}</strong>
          </span>
          <button
            onClick={handleToggleVisibility}
            disabled={isVisibilityUpdating}
            className={`px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white ${
              isVisibilityUpdating ? 'bg-gray-400' : profileData.profile.is_hidden ? 'bg-green-600 hover:bg-green-700' : 'bg-yellow-600 hover:bg-yellow-700'
            } focus:outline-none focus:ring-2 focus:ring-offset-2 ${
              profileData.profile.is_hidden ? 'focus:ring-green-500' : 'focus:ring-yellow-500'
            }`}
          >
            {isVisibilityUpdating
              ? 'Updating...'
              : profileData.profile.is_hidden
              ? 'Make Visible'
              : 'Hide Profile'}
          </button>
        </div>

        {/* Profile Data Display */}
        {isEditing ? (
            <ProfileEditView
                initialProfileData={profileData!} // Pass the loaded profile data
                onSave={handleEditSave}           // Pass the save handler
                onCancel={handleEditCancel}       // Pass the cancel handler
            />
          ) : (
            <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
              {/* Photo and Basic Info */}
              <div className="md:col-span-1 flex flex-col items-center"> {/* Added flex container for centering text fallback */}
                <PhotoWithFallbacks
                  src={profileData.profile.photo_w192 || ''} // Pass the photo URL or empty string
                  alt={`Profile picture of ${profileData.profile.name}`}
                  className="w-32 h-32 rounded-full object-cover mx-auto" // Pass Tailwind classes
                />
                <h2 className="text-xl font-semibold text-center mt-2">{profileData.profile.name}</h2>
                <p className="text-gray-600 text-center">({profileData.profile.is_hidden ? 'Hidden' : 'Visible'})</p>
              </div>

              {/* Main Details */}
              <div className="md:col-span-2 space-y-4">
                <div className="grid grid-cols-2 gap-4">
                  <div>
                    <p className="text-sm text-gray-500">Birth Date</p>
                    <p className="font-medium">{profileData.about.birth_date || 'Not specified'}</p>
                  </div>
                  <div>
                    <p className="text-sm text-gray-500">Gender</p>
                    <p className="font-medium">{formatGender(profileData.about.gender)}</p>
                  </div>
                  <div>
                    <p className="text-sm text-gray-500">Is Couple</p>
                    <p className="font-medium">{formatBoolean(profileData.about.is_couple)}</p>
                  </div>
                  <div>
                    <p className="text-sm text-gray-500">Has Children</p>
                    <p className="font-medium">{formatBoolean(profileData.about.has_children)}</p>
                  </div>
                  <div>
                    <p className="text-sm text-gray-500">Occupation</p>
                    <p className="font-medium">{formatOccupation(profileData.about.occupation_type)}</p>
                  </div>
                  <div>
                    <p className="text-sm text-gray-500">Drinking Level</p>
                    <p className="font-medium">{formatLevel(profileData.about.drinking_level, 'drinking')}</p>
                  </div>
                  <div>
                    <p className="text-sm text-gray-500">Smoking Level</p>
                    <p className="font-medium">{formatLevel(profileData.about.smoking_level, 'smoking')}</p>
                  </div>
                  {/* Add Smoking Type List */}
                  {profileData.about.smoking_level !== null && profileData.about.smoking_level > 1 && (
                    <div>
                      <p className="text-sm text-gray-500">Smoking Types</p>
                      <p className="font-medium text-gray-900"> {/* Standard text color, not indigo */}
                        {formatSmokingTypes(
                          profileData.about.smokes_iqos,
                          profileData.about.smokes_vape,
                          profileData.about.smokes_tobacco,
                          profileData.about.smokes_cigs
                        )}
                      </p>
                    </div>
                  )}
                </div>

                {/* Rent Preferences */}
                <div className="mt-4 p-4 bg-gray-50 rounded-lg">
                  <h3 className="text-lg font-medium text-gray-900 mb-2">Rent Preferences</h3>
                  <div className="grid grid-cols-2 gap-4">
                    <div>
                      <p className="text-sm text-gray-500">Min Budget</p>
                      <p className="font-medium">{profileData.rent_preferences.min_budget}</p>
                    </div>
                    <div>
                      <p className="text-sm text-gray-500">Max Budget</p>
                      <p className="font-medium">{profileData.rent_preferences.max_budget}</p>
                    </div>
                    <div>
                      <p className="text-sm text-gray-500">Min Duration</p>
                      <p className="font-medium">{formatLevel(profileData.rent_preferences.min_rent_duration_level, 'duration')}</p>
                    </div>
                    <div>
                      <p className="text-sm text-gray-500">Max Duration</p>
                      <p className="font-medium">{formatLevel(profileData.rent_preferences.max_rent_duration_level, 'duration')}</p>
                    </div>
                    <div>
                      <p className="text-sm text-gray-500">Room Sharing</p>
                      <p className="font-medium">{formatLevel(profileData.rent_preferences.room_sharing_level, 'room_sharing')}</p>
                    </div>
                  </div>
                  <div className="mt-2">
                      <p className="text-sm text-gray-500">Locations</p>
                      <div className="flex flex-wrap gap-1 mt-1">
                          {profileData.rent_preferences.locations ? (
                            // Call the function to get the processed array
                            prepareLocationsForDisplay(profileData.rent_preferences.locations).length > 0 ? (
                              // Map over the processed array
                              prepareLocationsForDisplay(profileData.rent_preferences.locations).map(
                                (item: DisplayLocation, index: number) => (
                                  <span
                                    key={`${item.type}-${index}`} // Use type and index for a more specific key
                                    className="inline-flex items-center px-2.5 py-0.5 rounded-full text-sm font-medium bg-blue-100 text-blue-800"
                                  >
                                    {item.displayName} {/* Render the pre-formatted display name */}
                                  </span>
                                )
                              )
                            ) : (
                              // Or show default if the processed array is empty
                              <p className="text-gray-600">–í—Å—è –£–∫—Ä–∞—ó–Ω–∞ (Default)</p>
                            )
                          ) : (
                            // Handle case where profileData.rent_preferences.locations is null/undefined
                            <p className="text-gray-600">–í—Å—è –£–∫—Ä–∞—ó–Ω–∞ (Default)</p>
                          )}
                      </div>
                  </div>
                </div>

                {/* Other Details */}
                <div className="mt-4 p-4 bg-gray-50 rounded-lg">
                  <h3 className="text-lg font-medium text-gray-900 mb-2">Other Details</h3>
                  <div className="grid grid-cols-2 gap-4">
                    <div>
                      <p className="text-sm text-gray-500">Neighbourliness</p>
                      <p className="font-medium">{formatLevel(profileData.about.neighbourliness_level, 'neighbourliness')}</p>
                    </div>
                    <div>
                      <p className="text-sm text-gray-500">Guests Level</p>
                      <p className="font-medium">{formatLevel(profileData.about.guests_level, 'guests')}</p>
                    </div>
                    <div>
                      <p className="text-sm text-gray-500">Parties Level</p>
                      <p className="font-medium">{formatLevel(profileData.about.parties_level, 'parties')}</p>
                    </div>
                    <div>
                      <p className="text-sm text-gray-500">Bedtime Level</p>
                      <p className="font-medium">{formatLevel(profileData.about.bedtime_level, 'bedtime')}</p>
                    </div>
                    <div>
                      <p className="text-sm text-gray-500">Neatness Level</p>
                      <p className="font-medium">{formatLevel(profileData.about.neatness_level, 'neatness')}</p>
                    </div>
                    {/* Pet Checkboxes - Display as a list */}
                    <div className="col-span-2"> {/* Use col-span-2 to make it full width */}
                      <p className="text-sm text-gray-500">Animals</p>
                      <p className="font-medium text-gray-900"> {/* Standard text color */}
                        {[
                          profileData.about.has_cats && 'Cats',
                          profileData.about.has_dogs && 'Dogs',
                          profileData.about.has_reptiles && 'Reptiles',
                          profileData.about.has_birds && 'Birds',
                        ].filter(Boolean).join(', ') || 'None'} {/* Filter out falsy values and join, default to 'None' */}
                      </p>
                    </div>
                    <div className="col-span-2">
                      <p className="text-sm text-gray-500">Other Animals</p>
                      <p className="font-medium">{joinArray(profileData.about.other_animals)}</p>
                    </div>
                    <div className="col-span-2">
                      <p className="text-sm text-gray-500">Interests</p>
                      <p className="font-medium">{joinArray(profileData.about.interests)}</p>
                    </div>
                    <div className="col-span-2">
                      <p className="text-sm text-gray-500">Bio</p>
                      <p className="font-medium break-words">{profileData.about.bio || 'Not specified'}</p>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          )}


        {/* Delete Button */}
        <div className="flex justify-end mt-6">
          <button
            onClick={() => setIsDeleteModalOpen(true)}
            className="px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-red-600 hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500"
          >
            Delete Profile & Account
          </button>
        </div>
      </div>

      {/* Delete Confirmation Modal */}
      {isDeleteModalOpen && (
        <div className="fixed z-50 inset-0 overflow-y-auto">
          <div className="flex items-end justify-center min-h-screen pt-4 px-4 pb-20 text-center sm:block sm:p-0">
            {/* Overlay: Semi-transparent background - Ensure it dims the content */}
            {/* Use fixed positioning, cover the screen, and apply opacity for dimming */}
            <div 
              className="fixed inset-0 bg-gray-500 transition-opacity" 
              style={{ opacity: 0.75 }} // Explicitly set opacity to ensure dimming effect
              aria-hidden="true"
              // Optional: Add an onClick handler here to close the modal when clicking the overlay
              // onClick={() => setIsDeleteModalOpen(false)}
            >
            </div>

            {/* Spacer element for vertical centering (hidden) */}
            <span className="hidden sm:inline-block sm:align-middle sm:h-screen" aria-hidden="true">&#8203</span>

            {/* Main Modal Content Container - Ensure it's above the overlay */}
            <div className="inline-block align-bottom bg-white rounded-lg text-left overflow-hidden shadow-xl transform transition-all sm:my-8 sm:align-middle sm:max-w-lg sm:w-full relative z-[51]"> {/* Increased z-index slightly to ensure it's above the overlay */}
              {/* Inner Content Div */}
              <div className="bg-white px-4 pt-5 pb-4 sm:p-6 sm:pb-4">
                <div className="sm:flex sm:items-start">
                  <div className="mx-auto flex-shrink-0 flex items-center justify-center h-12 w-12 rounded-full bg-red-100 sm:mx-0 sm:h-10 sm:w-10">
                    <svg className="h-6 w-6 text-red-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" aria-hidden="true">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L3.732 16.5c-.77.833.192 2.5 1.732 2.5z" />
                    </svg>
                  </div>
                  <div className="mt-3 text-center sm:mt-0 sm:ml-4 sm:text-left">
                    <h3 className="text-lg leading-6 font-medium text-gray-900" id="modal-title">
                      Delete Profile & Account
                    </h3>
                    <div className="mt-2">
                      <p className="text-sm text-gray-500">
                        Are you sure you want to delete your profile and account? This action cannot be undone. All your data will be permanently removed.
                      </p>
                    </div>
                  </div>
                </div>
              </div>
              {/* Footer with Buttons */}
              <div className="bg-gray-50 px-4 py-3 sm:px-6 sm:flex sm:flex-row-reverse">
                <button
                  type="button"
                  onClick={handleDeleteConfirm}
                  disabled={isDeleting}
                  className={`w-full inline-flex justify-center rounded-md border border-transparent shadow-sm px-4 py-2 text-base font-medium text-white sm:ml-3 sm:w-auto sm:text-sm ${
                    isDeleting ? 'bg-gray-400' : 'bg-red-600 hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500'
                  }`}
                >
                  {isDeleting ? 'Deleting...' : 'Delete'}
                </button>
                <button
                  type="button"
                  onClick={() => setIsDeleteModalOpen(false)} // Close the modal
                  className="mt-3 w-full inline-flex justify-center rounded-md border border-gray-300 shadow-sm px-4 py-2 bg-white text-base font-medium text-gray-700 hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 sm:mt-0 sm:ml-3 sm:w-auto sm:text-sm"
                >
                  Cancel
                </button>
              </div>
            </div>
          </div>
        </div>
      )}
    </div>
  )
}
_____________________________

shallwe_frontend/src/app/setup/page.tsx:

'use client'


import { useEffect, useState } from 'react'
import { useRouter } from 'next/navigation'

import { TagsInput } from "react-tag-input-component"

import ProfilePhotoPick from '../components/profile/ProfilePhotoPick'
import Locations from '../components/profile/Locations'

import { env } from '@/config/env'
import { getDocumentCookie } from '@/lib/common/cookie'
import { ProfileCreateFormState, profileCreateFormStateInitial } from '@/lib/shallwe/profile/formstates/states' 
import { collectProfileCreateDataFromState } from '@/lib/shallwe/profile/formstates/collectors/create'
import { validateProfileCreateFields } from '@/lib/shallwe/profile/formstates/validators/create'
import { ValidationResult, validators } from '@/lib/shallwe/profile/formstates/validators/common'
import { ProfileCreateData } from '@/lib/shallwe/profile/api/schema/create'
import { createProfile } from '@/lib/shallwe/profile/api/calls'
import { ApiError } from '@/lib/shallwe/common/api/calls'
import BirthDateSelect from '../components/profile/BirthDateSelect'


// Dividing visual flow in steps for better UX
const STEPS = [
  { id: 'profile', name: 'Basic Info' },
  { id: 'about', name: 'About You' },
  { id: 'preferences', name: 'Rent Preferences' },
]


// Fields that are validated beyond basic type match
const STEP_0_FIELDS_TO_VALIDATE = [
  'profile.name',
  'profile.photo',
]
const STEP_1_FIELDS_TO_VALIDATE = [
  'about.birth_date',
  'about.gender',
  'about.is_couple',
  'about.has_children',
  'about.smoking_level',
  'about.other_animals',
  'about.interests',
  'about.bio',
]
const STEP_2_FIELDS_VALIDATE = [
  'rent_preferences.min_budget',
  'rent_preferences.max_budget',
  'rent_preferences.min_rent_duration_level',
  'rent_preferences.max_rent_duration_level',
  'rent_preferences.locations',
]


export default function ProfileSetupPage() {
  const [currentStep, setCurrentStep] = useState(0)
  const [formState, setFormState] = useState<ProfileCreateFormState>(profileCreateFormStateInitial)
  const [errors, setErrors] = useState<Record<string, string>>({})
  const [generalError, setGeneralError] = useState<string | null>(null)
  const [apiError, setApiError] = useState<string | null>(null)
  const [isLoading, setIsLoading] = useState(false)
  const router = useRouter()

  const [isAboutAccordionOpen, setIsAboutAccordionOpen] = useState(false)
  const [locationsApiError, setLocationsApiError] = useState<string | null>(null)


  // Skip to Step N (DEV test feature)
  useEffect(() => {
    if (env.NEXT_PUBLIC_SHALLWE_ENV_MODE === 'DEV') {
      const skipCookieName = 'shallwe_test_profile_create_skip_to_step'

      const skipToStepValue = getDocumentCookie(skipCookieName)
      console.log(`ProfileSetupPage: Found cookie '${skipCookieName}': ${skipToStepValue}`)

      if (skipToStepValue) {
        const targetStep = parseInt(skipToStepValue, 10)
        if (!isNaN(targetStep) && targetStep >= 0 && targetStep <= 2) {
          console.log(`ProfileSetupPage: QA Cookie requests skipping to step ${targetStep}.`)
          setCurrentStep(targetStep)
        }
        else {
          console.warn(`ProfileSetupPage: Invalid step number '${skipToStepValue}' found in cookie '${skipCookieName}'. Ignoring.`) // Optional: Log warning
        }
      }
    }
  }, [])


  // Define a helper function to run validation and update errors
  const validateCurrentTagsInput = (fieldName: string, tagsToValidate: string[], validatorKey: string) => {
    const validationError = validators[validatorKey](tagsToValidate, formState);
    setErrors(prevErrors => {
      const newErrors = { ...prevErrors };
      if (validationError !== null) {
        newErrors[fieldName] = validationError;
      } else {
        delete newErrors[fieldName]; // Clear error if validation passes
      }
      return newErrors;
    });
    return validationError
  };


  const updateSmokingLevelAndClearTypes = (newLevel: ProfileCreateFormState['about']['smoking_level']) => {
    setGeneralError(null);
    setFormState(prev => {
      const updatedAbout = { ...prev.about, smoking_level: newLevel };

      // Check if the new level is null or 1
      if (newLevel === null || newLevel === 1) {
        // Reset smoking type booleans to false
        updatedAbout.smokes_iqos = false;
        updatedAbout.smokes_vape = false;
        updatedAbout.smokes_tobacco = false;
        updatedAbout.smokes_cigs = false;
      }

      return {
        ...prev,
        about: updatedAbout,
      };
    });

    // Clear specific field error when user starts typing/modifying
    if (errors['about.smoking_level']) {
      setErrors(prev => {
        const newErrors = { ...prev };
        delete newErrors['about.smoking_level'];
        return newErrors;
      });
    }
  };
  

  // Update the photo handler to interact with the PhotoCropper component
  const handlePhotoCropped = (croppedFile: File) => {
    updateFormState('profile', 'photo', croppedFile)
  }

  // Callback for PhotoCropper to set error in the main page's state
  const handlePhotoError = (error: string) => {
    setErrors(prevErrors => ({
        ...prevErrors,
        'profile.photo': error // Set the specific field error
    }))
  }

  // Callback for PhotoCropper to clear error in the main page's state
  const clearPhotoError = () => {
    setErrors(prevErrors => {
        const newErrors = { ...prevErrors }
        delete newErrors['profile.photo'] // Remove the specific field error
        return newErrors
    })
  }


  const clearLocationsApiError = () => {
     if (locationsApiError) {
         setLocationsApiError(null)
     }
  }


  const updateFormState = <S extends keyof ProfileCreateFormState, F extends keyof ProfileCreateFormState[S]>(
    section: S, field: F, value: ProfileCreateFormState[S][F]
  ) => {
    setGeneralError(null)
    setFormState(prev => ({
      ...prev,
      [section]: {
        ...prev[section],
        [field]: value,
      },
    }))
    // Clear specific field error when user starts typing/modifying
    if (errors[`${section}.${String(field)}`]) {
      setErrors(prev => {
        const newErrors = { ...prev }
        delete newErrors[`${section}.${String(field)}`]
        return newErrors
      })
    }
  }


  const validateCurrentStep = (): boolean => {
    let fieldsToValidate: string[] = []
    switch (currentStep) {
      case 0:
        fieldsToValidate = STEP_0_FIELDS_TO_VALIDATE
        break
      case 1:
        fieldsToValidate = STEP_1_FIELDS_TO_VALIDATE
        break
      case 2:
        fieldsToValidate = STEP_2_FIELDS_VALIDATE
        break
      default:
        fieldsToValidate = []
    }

    const validation: ValidationResult = validateProfileCreateFields(formState, fieldsToValidate)
    setErrors(validation.errors)
    return validation.isValid
  }


  const validateAllFields = (): ValidationResult => {
    // Validate all fields for final submission
    const allFields = [...STEP_0_FIELDS_TO_VALIDATE, ...STEP_1_FIELDS_TO_VALIDATE, ...STEP_2_FIELDS_VALIDATE]
    const validation: ValidationResult = validateProfileCreateFields(formState, allFields)
    setErrors(validation.errors)
    return validation
  }


  const nextStep = () => {
    setGeneralError(null)
    if (validateCurrentStep()) {
      if (currentStep < STEPS.length - 1) {
        setCurrentStep(prev => prev + 1)
      }
    }
  }


  const prevStep = () => {
    setGeneralError(null)
    if (currentStep > 0) {
      setCurrentStep(prev => prev - 1)
    }
  }


  const handleSubmit = async () => {
    setGeneralError(null)
    setIsLoading(true)

    const validationResult = validateAllFields()
    if (!validationResult.isValid) {
      console.log("Final validation failed, cannot submit.");
      // Set a user-facing error message
      const prevStepErrors = Object.keys(validationResult.errors).filter(
        fieldName => !STEP_2_FIELDS_VALIDATE.includes(fieldName)
      );

      if (prevStepErrors.length > 0) {
        const prevStepsInvalidFields = prevStepErrors.join(", ");
        setGeneralError(`Some previous fields weren't correct, please check again: ${prevStepsInvalidFields}.`);
      }

      setIsLoading(false); // Stop loading state as submission is halted
      return; // Do not proceed if final validation fails
    }

    setApiError(null)
    setErrors({}) // Clear previous API errors (and client-side validation errors)

    try {
      const profileDataToSend: ProfileCreateData = collectProfileCreateDataFromState(formState);
      console.log("Collected Profile Data for API:", profileDataToSend); // Debug log
      await createProfile(profileDataToSend);
      console.log("Profile created successfully!");
      router.push('/settings');
    } catch (error) {
      console.error("Error creating profile:", error);
      // Handle API errors here, potentially setting 'generalError' or 'apiError'
      let errorMessage = "An unexpected error occurred.";
      if (error && typeof error === 'object' && 'details' in error) {
        const err = error as ApiError;
        console.log("API Error Details:", err.details);
        if (err.details && typeof err.details === 'object' && 'error' in err.details) {
          const apiErrors = err.details.error;
          if (typeof apiErrors === 'object') {
            // You might want to format this object into a more user-friendly string
            errorMessage = JSON.stringify(apiErrors);
          } else if (typeof apiErrors === 'string') {
            errorMessage = apiErrors;
          } else {
             errorMessage = "Received an unexpected error format from the server.";
          }
        } else {
          errorMessage = err.message || errorMessage;
        }
      } else if (error instanceof Error) {
        errorMessage = error.message;
      }
      setGeneralError(errorMessage); // Use the general error state for API errors too, or keep separate 'apiError'
    } finally {
      setIsLoading(false); // Always stop loading state in 'finally'
    }
  };


  // --- STEP RENDER OPTIONS ---
  const getStepContent = () => {
    switch (currentStep) {
      
      // Step 1 Basic info
      case 0:
        return (
          <div className="space-y-4">
            <h2 className="text-xl font-semibold">Profile Details</h2>
            <div>
              <label htmlFor="name" className="block text-sm font-medium text-gray-700">
                Name (Cyrillic only)
              </label>
              <input
                type="text"
                id="name"
                value={formState.profile.name ?? ''} // Use ?? '' to handle null
                onChange={(e) => updateFormState('profile', 'name', e.target.value || null)} // Convert empty string back to null if needed, though the ?? '' handles display
                className={`mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm ${
                  errors['profile.name'] ? 'border-red-500' : ''
                }`}
              />
              {errors['profile.name'] && <p className="mt-1 text-sm text-red-600">{errors['profile.name']}</p>}
            </div>

            <div>
              <ProfilePhotoPick
                initialFile={formState.profile.photo} // Pass the current photo if editing
                onError={handlePhotoError}
                onClearError={clearPhotoError}
                onCropComplete={handlePhotoCropped}
                // Removed formState and fieldPath props
              />
              {/* Display central validation error for photo if it exists (e.g., required but not set after crop) */}
              {/* This error will appear if the user proceeds without a valid photo after the component's internal checks */}
              {errors['profile.photo'] && <p className="mt-1 text-sm text-red-600">{errors['profile.photo']}</p>}
            </div>
          </div>
        )
      
      // Step 2 About
      case 1:
        return (
          <div className="space-y-4">
            <h2 className="text-xl font-semibold">About You</h2>

            {/* Required fields (birth_date, gender, is_couple, has_children) remain outside the accordion */}
            <BirthDateSelect
              inputId="birth_date"
              currentValue={formState.about.birth_date} // Pass the string value from state
              onChange={(dateString) => updateFormState('about', 'birth_date', dateString)} // Pass the update handler
              error={errors['about.birth_date']} // Pass the error message
              className={`${errors['about.birth_date'] ? 'border-red-500' : ''}`} // Pass specific Tailwind classes if needed
            />

            {/* Gender */}
            <div>
              <fieldset>
                <legend className="text-sm font-medium text-gray-700">Gender</legend>
                <div className="mt-1 space-y-2">
                  {[
                    { id: 'gender_male', value: 1, label: 'Male' },
                    { id: 'gender_female', value: 2, label: 'Female' },
                  ].map((option) => (
                    <div key={option.id} className="flex items-center">
                      <input
                        id={option.id}
                        name="gender"
                        type="radio"
                        checked={formState.about.gender === option.value}
                        onChange={() => updateFormState('about', 'gender', option.value as 1 | 2)}
                        className="h-4 w-4 border-gray-300 text-indigo-600 focus:ring-indigo-500"
                      />
                      <label htmlFor={option.id} className="ml-3 block text-sm text-gray-700">
                        {option.label}
                      </label>
                    </div>
                  ))}
                </div>
                {errors['about.gender'] && (
                  <p className="mt-1 text-sm text-red-600">{errors['about.gender']}</p>
                )}
              </fieldset>
            </div>

            {/* Is Couple */}
            <div className="flex flex-col mt-2">
              <div className="flex items-center">
                <input
                  id="is_couple"
                  type="checkbox"
                  checked={formState.about.is_couple === true}
                  onChange={(e) => updateFormState('about', 'is_couple', e.target.checked)}
                  className="h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500"
                />
                <label htmlFor="is_couple" className="ml-2 block text-sm text-gray-700">
                  Is Couple
                </label>
              </div>
              {errors['about.is_couple'] && (
                <p className="mt-1 text-sm text-red-600">{errors['about.is_couple']}</p>
              )}
            </div>

            {/* Has Children */}
            <div className="flex flex-col mt-2">
              <div className="flex items-center">
                <input
                  id="has_children"
                  type="checkbox"
                  checked={formState.about.has_children === true}
                  onChange={(e) => updateFormState('about', 'has_children', e.target.checked)}
                  className="h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500"
                />
                <label htmlFor="has_children" className="ml-2 block text-sm text-gray-700">
                  Has Children
                </label>
              </div>
              {errors['about.has_children'] && (
                <p className="mt-1 text-sm text-red-600">{errors['about.has_children']}</p>
              )}
            </div>

            {/* Optional Fields Accordion */}
            <div className="border border-gray-200 rounded-md">
              <button
                type="button"
                onClick={() => setIsAboutAccordionOpen(!isAboutAccordionOpen)}
                className="w-full flex justify-between items-center p-4 text-left focus:outline-none"
              >
                <span className="text-sm font-medium text-gray-700">Optional Details</span>
                <svg
                  className={`h-5 w-5 text-gray-400 transform ${isAboutAccordionOpen ? 'rotate-180' : ''}`}
                  xmlns="http://www.w3.org/2000/svg"
                  viewBox="0 0 20 20"
                  fill="currentColor"
                  aria-hidden="true"
                >
                  <path
                    fillRule="evenodd"
                    d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z"
                    clipRule="evenodd"
                  />
                </svg>
              </button>
              {isAboutAccordionOpen && (
                <div className="p-4 space-y-4 border-t border-gray-200">
                  {/* occupation_type (select) */}
                  <div>
                    <label htmlFor="occupation_type" className="block text-sm font-medium text-gray-700">
                      Occupation Type
                    </label>
                    <select
                      id="occupation_type"
                      value={formState.about.occupation_type ?? ''}
                      onChange={(e) => updateFormState('about', 'occupation_type', e.target.value ? Number(e.target.value) as 1 | 2 | 3 | 4 : null)}
                      className={`mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm ${
                        errors['about.occupation_type'] ? 'border-red-500' : ''
                      }`}
                    >
                      <option value="">Select...</option>
                      <option value="1">Employed</option>
                      <option value="2">Student</option>
                      <option value="3">Unemployed</option>
                      <option value="4">Retired</option>
                    </select>
                    {errors['about.occupation_type'] && <p className="mt-1 text-sm text-red-600">{errors['about.occupation_type']}</p>}
                  </div>

                  {/* drinking_level (select) */}
                  <div>
                    <label htmlFor="drinking_level" className="block text-sm font-medium text-gray-700">
                      Drinking Level
                    </label>
                    <select
                      id="drinking_level"
                      value={formState.about.drinking_level ?? ''}
                      onChange={(e) => updateFormState('about', 'drinking_level', e.target.value ? Number(e.target.value) as 1 | 2 | 3 | 4 : null)}
                      className={`mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm ${
                        errors['about.drinking_level'] ? 'border-red-500' : ''
                      }`}
                    >
                      <option value="">Select...</option>
                      <option value="1">Never</option>
                      <option value="2">Rarely</option>
                      <option value="3">Socially</option>
                      <option value="4">Often</option>
                    </select>
                    {errors['about.drinking_level'] && <p className="mt-1 text-sm text-red-600">{errors['about.drinking_level']}</p>}
                  </div>

                  {/* smoking_level (select) */}
                  <div>
                    <label htmlFor="smoking_level" className="block text-sm font-medium text-gray-700">
                      Smoking Level
                    </label>
                    <select
                      id="smoking_level"
                      value={formState.about.smoking_level ?? ''}
                      onChange={(e) => updateSmokingLevelAndClearTypes(e.target.value ? Number(e.target.value) as 1 | 2 | 3 | 4 : null)}
                      className={`mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm ${
                        errors['about.smoking_level'] ? 'border-red-500' : ''
                      }`}
                    >
                      <option value="">Select...</option>
                      <option value="1">Never</option>
                      <option value="2">Rarely</option>
                      <option value="3">Socially</option>
                      <option value="4">Often</option>
                    </select>
                    {errors['about.smoking_level'] && <p className="mt-1 text-sm text-red-600">{errors['about.smoking_level']}</p>}
                  </div>

                  {/* Smoking Type Checkboxes (Conditional based on smoking_level) */}
                  {formState.about.smoking_level !== null && formState.about.smoking_level > 1 && (
                    <div className="col-span-2 mt-2"> {/* Use col-span-2 to span full width, add top margin */}
                      <p className="text-sm font-medium text-gray-700 mb-1">Smoking Types:</p> {/* Label for the group */}
                      <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-4 gap-2"> {/* Grid layout: 1 column on mobile, 2 on small screens, 4 on medium+ screens */}
                        <div className="flex items-center">
                          <input
                            id="smokes_iqos"
                            type="checkbox"
                            checked={formState.about.smokes_iqos === true}
                            onChange={(e) => updateFormState('about', 'smokes_iqos', e.target.checked)}
                            className="h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500"
                          />
                          <label htmlFor="smokes_iqos" className="ml-2 block text-sm text-gray-700">
                            IQOS
                          </label>
                        </div>
                        <div className="flex items-center">
                          <input
                            id="smokes_vape"
                            type="checkbox"
                            checked={formState.about.smokes_vape === true}
                            onChange={(e) => updateFormState('about', 'smokes_vape', e.target.checked)}
                            className="h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500"
                          />
                          <label htmlFor="smokes_vape" className="ml-2 block text-sm text-gray-700">
                            Vape
                          </label>
                        </div>
                        <div className="flex items-center">
                          <input
                            id="smokes_tobacco"
                            type="checkbox"
                            checked={formState.about.smokes_tobacco === true}
                            onChange={(e) => updateFormState('about', 'smokes_tobacco', e.target.checked)}
                            className="h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500"
                          />
                          <label htmlFor="smokes_tobacco" className="ml-2 block text-sm text-gray-700">
                            Tobacco
                          </label>
                        </div>
                        <div className="flex items-center">
                          <input
                            id="smokes_cigs"
                            type="checkbox"
                            checked={formState.about.smokes_cigs === true}
                            onChange={(e) => updateFormState('about', 'smokes_cigs', e.target.checked)}
                            className="h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500"
                          />
                          <label htmlFor="smokes_cigs" className="ml-2 block text-sm text-gray-700">
                            Cigarettes
                          </label>
                        </div>
                        </div>
                    </div>
                  )}

                  {/* neighbourliness_level (select) */}
                  <div>
                    <label htmlFor="neighbourliness_level" className="block text-sm font-medium text-gray-700">
                      Neighbourliness Level
                    </label>
                    <select
                      id="neighbourliness_level"
                      value={formState.about.neighbourliness_level ?? ''}
                      onChange={(e) => updateFormState('about', 'neighbourliness_level', e.target.value ? Number(e.target.value) as 1 | 2 | 3 : null)}
                      className={`mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm ${
                        errors['about.neighbourliness_level'] ? 'border-red-500' : ''
                      }`}
                    >
                      <option value="">Select...</option>
                      <option value="1">Low</option>
                      <option value="2">Medium</option>
                      <option value="3">High</option>
                    </select>
                    {errors['about.neighbourliness_level'] && <p className="mt-1 text-sm text-red-600">{errors['about.neighbourliness_level']}</p>}
                  </div>

                  {/* guests_level (select) */}
                  <div>
                    <label htmlFor="guests_level" className="block text-sm font-medium text-gray-700">
                      Guests Level
                    </label>
                    <select
                      id="guests_level"
                      value={formState.about.guests_level ?? ''}
                      onChange={(e) => updateFormState('about', 'guests_level', e.target.value ? Number(e.target.value) as 1 | 2 | 3 : null)}
                      className={`mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm ${
                        errors['about.guests_level'] ? 'border-red-500' : ''
                      }`}
                    >
                      <option value="">Select...</option>
                      <option value="1">Low</option>
                      <option value="2">Medium</option>
                      <option value="3">High</option>
                    </select>
                    {errors['about.guests_level'] && <p className="mt-1 text-sm text-red-600">{errors['about.guests_level']}</p>}
                  </div>

                  {/* parties_level (select) */}
                  <div>
                    <label htmlFor="parties_level" className="block text-sm font-medium text-gray-700">
                      Parties Level
                    </label>
                    <select
                      id="parties_level"
                      value={formState.about.parties_level ?? ''}
                      onChange={(e) => updateFormState('about', 'parties_level', e.target.value ? Number(e.target.value) as 1 | 2 | 3 : null)}
                      className={`mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm ${
                        errors['about.parties_level'] ? 'border-red-500' : ''
                      }`}
                    >
                      <option value="">Select...</option>
                      <option value="1">Low</option>
                      <option value="2">Medium</option>
                      <option value="3">High</option>
                    </select>
                    {errors['about.parties_level'] && <p className="mt-1 text-sm text-red-600">{errors['about.parties_level']}</p>}
                  </div>

                  {/* bedtime_level (select) */}
                  <div>
                    <label htmlFor="bedtime_level" className="block text-sm font-medium text-gray-700">
                      Bedtime Level
                    </label>
                    <select
                      id="bedtime_level"
                      value={formState.about.bedtime_level ?? ''}
                      onChange={(e) => updateFormState('about', 'bedtime_level', e.target.value ? Number(e.target.value) as 1 | 2 | 3 | 4 : null)}
                      className={`mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm ${
                        errors['about.bedtime_level'] ? 'border-red-500' : ''
                      }`}
                    >
                      <option value="">Select...</option>
                      <option value="1">Early (e.g., 22:00)</option>
                      <option value="2">Midnight</option>
                      <option value="3">Late (e.g., 02:00)</option>
                      <option value="4">Very Late (e.g., 04:00)</option>
                    </select>
                    {errors['about.bedtime_level'] && <p className="mt-1 text-sm text-red-600">{errors['about.bedtime_level']}</p>}
                  </div>

                  {/* neatness_level (select) */}
                  <div>
                    <label htmlFor="neatness_level" className="block text-sm font-medium text-gray-700">
                      Neatness Level
                    </label>
                    <select
                      id="neatness_level"
                      value={formState.about.neatness_level ?? ''}
                      onChange={(e) => updateFormState('about', 'neatness_level', e.target.value ? Number(e.target.value) as 1 | 2 | 3 : null)}
                      className={`mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm ${
                        errors['about.neatness_level'] ? 'border-red-500' : ''
                      }`}
                    >
                      <option value="">Select...</option>
                      <option value="1">Low</option>
                      <option value="2">Medium</option>
                      <option value="3">High</option>
                    </select>
                    {errors['about.neatness_level'] && <p className="mt-1 text-sm text-red-600">{errors['about.neatness_level']}</p>}
                  </div>

                  {/* Pet Checkboxes */}
                  <div className="col-span-2 mt-2">
                    <p className="text-sm font-medium text-gray-700 mb-1">I Have Animals:</p>
                    <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-4 gap-4">
                      <div className="col-start-1 flex items-center">
                        <input
                          id="has_cats"
                          type="checkbox"
                          checked={formState.about.has_cats === true}
                          onChange={(e) => updateFormState('about', 'has_cats', e.target.checked)}
                          className="h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500"
                        />
                        <label htmlFor="has_cats" className="ml-2 block text-sm text-gray-700">
                          Has Cats
                        </label>
                      </div>
                      <div className="flex items-center">
                        <input
                          id="has_dogs"
                          type="checkbox"
                          checked={formState.about.has_dogs === true}
                          onChange={(e) => updateFormState('about', 'has_dogs', e.target.checked)}
                          className="h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500"
                        />
                        <label htmlFor="has_dogs" className="ml-2 block text-sm text-gray-700">
                          Has Dogs
                        </label>
                      </div>
                      <div className="flex items-center">
                        <input
                          id="has_reptiles"
                          type="checkbox"
                          checked={formState.about.has_reptiles === true}
                          onChange={(e) => updateFormState('about', 'has_reptiles', e.target.checked)}
                          className="h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500"
                        />
                        <label htmlFor="has_reptiles" className="ml-2 block text-sm text-gray-700">
                          Has Reptiles
                        </label>
                      </div>
                      <div className="flex items-center">
                        <input
                          id="has_birds"
                          type="checkbox"
                          checked={formState.about.has_birds === true}
                          onChange={(e) => updateFormState('about', 'has_birds', e.target.checked)}
                          className="h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500"
                        />
                        <label htmlFor="has_birds" className="ml-2 block text-sm text-gray-700">
                          Has Birds
                        </label>
                      </div>
                    </div>
                  </div>

                  {/* other_animals (text input - comma separated, validated by validator) */}
                  <div>
                    <label htmlFor="other_animals" className="block text-sm font-medium text-gray-700">
                      Other Animals (up to 5)
                    </label>
                    <TagsInput
                      isEditOnRemove
                      value={formState.about.other_animals || []}
                      beforeAddValidate={(newTag: string, currentTags: string[]) => {
                        const newTagsCandidate = [...currentTags, newTag];
                        const validationError = validators['about.other_animals'](newTagsCandidate, formState);
                        // Update the main errors state if validation fails
                        if (validationError !== null) {
                          setErrors(prevErrors => ({
                            ...prevErrors,
                            'about.other_animals': validationError
                          }));
                          return false; // Prevent adding the tag
                        }

                        // Clear the specific error for this field if validation passes
                        setErrors(prevErrors => {
                          const newErrors = { ...prevErrors };
                          delete newErrors['about.other_animals']; // Remove the error for this key
                          return newErrors;
                        });
                        return true; // Allow adding the tag
                      }}
                      onChange={(tags: string[]) => {
                        // Clear the specific error for this field whenever tags change
                        // This happens after a successful add (when beforeAddValidate passed)
                        // or a remove action.
                        setErrors(prevErrors => {
                          const newErrors = { ...prevErrors };
                          delete newErrors['about.other_animals']; // Remove the error for this key
                          return newErrors;
                        });
                        updateFormState('about', 'other_animals', tags);
                      }}
                      onKeyUp={(e: React.KeyboardEvent<HTMLInputElement>) => {
                        const inputValue = (e.target as HTMLInputElement).value;

                        if (inputValue) {
                          const currentTags = formState.about.other_animals || []; // Use current state
                          const newTagsCandidate = [...currentTags, inputValue];
                          validateCurrentTagsInput('about.other_animals', newTagsCandidate, 'about.other_animals');
                        }
                        else {
                          const currentTags = formState.about.other_animals || [];
                          validateCurrentTagsInput('about.other_animals', currentTags, 'about.other_animals');
                        }
                      }}
                      onBlur={(e: React.FocusEvent<HTMLInputElement>) => {
                        const inputElement = e.target as HTMLInputElement
                        const inputValue = inputElement.value
                        if (inputValue) {
                          inputElement.value = ''
                          setErrors(prevErrors => {
                            const newErrors = { ...prevErrors };
                            delete newErrors['about.other_animals']; // Remove the error for this key
                            return newErrors;
                          })
                        }
                      }}
                      name="other_animals"
                      placeHolder="Type and press enter"
                      classNames={{
                        tag: "bg-blue-100 text-blue-800 px-2 py-1 rounded-md text-sm",
                        input: "mt-0 block w-full p-0 text-sm focus:outline-none",
                      }}
                    />
                    {errors['about.other_animals'] && <p className="mt-1 text-sm text-red-600">{errors['about.other_animals']}</p>}
                  </div>

                  {/* interests (text input - comma separated, validated by validator) */}
                  <div>
                    <label htmlFor="interests" className="block text-sm font-medium text-gray-700">
                      Interests (up to 5)
                    </label>
                    <TagsInput
                      isEditOnRemove
                      value={formState.about.interests || []}
                      beforeAddValidate={(newTag: string, currentTags: string[]) => {
                        const newTagsCandidate = [...currentTags, newTag];
                        const validationError = validators['about.interests'](newTagsCandidate, formState);
                        // Update the main errors state if validation fails
                        if (validationError !== null) {
                          setErrors(prevErrors => ({
                            ...prevErrors,
                            'about.interests': validationError
                          }));
                          return false; // Prevent adding the tag
                        }

                        // Clear the specific error for this field if validation passes
                        setErrors(prevErrors => {
                          const newErrors = { ...prevErrors };
                          delete newErrors['about.interests']; // Remove the error for this key
                          return newErrors;
                        });
                        return true; // Allow adding the tag
                      }}
                      onChange={(tags) => {
                        setErrors(prevErrors => {
                          const newErrors = { ...prevErrors };
                          delete newErrors['about.interests']; // Remove the error for this key
                          return newErrors;
                        });
                        updateFormState('about', 'interests', tags)
                      }}
                      onKeyUp={(e: React.KeyboardEvent<HTMLInputElement>) => {
                        const inputValue = (e.target as HTMLInputElement).value;

                        if (inputValue) {
                          const currentTags = formState.about.interests || []; // Use current state
                          const newTagsCandidate = [...currentTags, inputValue];
                          validateCurrentTagsInput('about.interests', newTagsCandidate, 'about.interests');
                        }
                        else {
                          const currentTags = formState.about.interests || [];
                          validateCurrentTagsInput('about.interests', currentTags, 'about.interests');
                        }
                      }}
                      onBlur={(e: React.FocusEvent<HTMLInputElement>) => {
                        const inputElement = e.target as HTMLInputElement
                        const inputValue = inputElement.value
                        if (inputValue) {
                          inputElement.value = ''
                          setErrors(prevErrors => {
                            const newErrors = { ...prevErrors };
                            delete newErrors['about.interests']; // Remove the error for this key
                            return newErrors;
                          })
                        }
                      }}
                      name="interests"
                      placeHolder="Type and press enter"
                      classNames={{
                        tag: "bg-blue-100 text-blue-800 px-2 py-1 rounded-md text-sm",
                        input: "mt-0 block w-full p-0 text-sm focus:outline-none",
                      }}
                    />
                    {errors['about.interests'] && <p className="mt-1 text-sm text-red-600">{errors['about.interests']}</p>}
                  </div>

                  {/* bio (textarea) */}
                  <div>
                    <label htmlFor="bio" className="block text-sm font-medium text-gray-700">
                      Bio (up to 1024 chars)
                    </label>
                    <textarea
                      id="bio"
                      rows={3}
                      value={formState.about.bio ?? ''}
                      onChange={(e) => updateFormState('about', 'bio', e.target.value || null)}
                      className={`mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm ${
                        errors['about.bio'] ? 'border-red-500' : // Prioritize validation errors
                        (formState.about.bio && formState.about.bio.length > 1024 ? 'border-red-500' : 'border-gray-300') // Check char limit
                      }`}
                    />
                    <p className={`text-xs mt-1 ${
                      formState.about.bio && formState.about.bio.length > 1024 ? 'text-red-600' : 'text-gray-500' // Change color based on limit
                    }`}>
                      {formState.about.bio ? formState.about.bio.length : 0} / 1024 characters
                    </p>
                    {errors['about.bio'] && <p className="mt-1 text-sm text-red-600">{errors['about.bio']}</p>}
                  </div>
                </div>
              )}
            </div>
            {/* End of Optional Fields Accordion */}

          </div>
        )
      
      // Step 3 Rent
      case 2:
        return (
          <div className="space-y-4">
            <h2 className="text-xl font-semibold">Rent Preferences</h2>
            {/* Add fields for rent_preferences section: budgets, duration, room sharing, locations */}
            <div className="grid grid-cols-2 gap-4">
              <div>
                <label htmlFor="min_budget" className="block text-sm font-medium text-gray-700">
                  Min Budget
                </label>
                <input
                  type="number"
                  id="min_budget"
                  value={formState.rent_preferences.min_budget ?? ''} // Use ?? '' to handle null
                  onChange={(e) => updateFormState('rent_preferences', 'min_budget', e.target.value ? Number(e.target.value) : null)}
                  className={`mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm ${
                    errors['rent_preferences.min_budget'] ? 'border-red-500' : ''
                  }`}
                />
                {errors['rent_preferences.min_budget'] && <p className="mt-1 text-sm text-red-600">{errors['rent_preferences.min_budget']}</p>}
              </div>
              <div>
                <label htmlFor="max_budget" className="block text-sm font-medium text-gray-700">
                  Max Budget
                </label>
                <input
                  type="number"
                  id="max_budget"
                  value={formState.rent_preferences.max_budget ?? ''} // Use ?? '' to handle null
                  onChange={(e) => updateFormState('rent_preferences', 'max_budget', e.target.value ? Number(e.target.value) : null)}
                  className={`mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm ${
                    errors['rent_preferences.max_budget'] ? 'border-red-500' : ''
                  }`}
                />
                {errors['rent_preferences.max_budget'] && <p className="mt-1 text-sm text-red-600">{errors['rent_preferences.max_budget']}</p>}
              </div>
            </div>
            {/* Add other 'rent_preferences' fields similarly */}
            {/* min_rent_duration_level (select) */}
            <div>
                <label htmlFor="min_rent_duration_level" className="block text-sm font-medium text-gray-700">
                  Min Rent Duration Level
                </label>
                <select
                  id="min_rent_duration_level"
                  value={formState.rent_preferences.min_rent_duration_level ?? ''} // Use ?? '' to handle null
                  onChange={(e) => updateFormState('rent_preferences', 'min_rent_duration_level', e.target.value ? Number(e.target.value) : null)}
                  className={`mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm ${
                    errors['rent_preferences.min_rent_duration_level'] ? 'border-red-500' : ''
                  }`}
                >
                  <option value="">Select...</option>
                  <option value="1">Level 1</option>
                  <option value="2">Level 2</option>
                  <option value="3">Level 3</option>
                  <option value="4">Level 4</option>
                  <option value="5">Level 5</option>
                </select>
                {errors['rent_preferences.min_rent_duration_level'] && <p className="mt-1 text-sm text-red-600">{errors['rent_preferences.min_rent_duration_level']}</p>}
            </div>

            {/* max_rent_duration_level (select) */}
            <div>
                <label htmlFor="max_rent_duration_level" className="block text-sm font-medium text-gray-700">
                  Max Rent Duration Level
                </label>
                <select
                  id="max_rent_duration_level"
                  value={formState.rent_preferences.max_rent_duration_level ?? ''} // Use ?? '' to handle null
                  onChange={(e) => updateFormState('rent_preferences', 'max_rent_duration_level', e.target.value ? Number(e.target.value) : null)}
                  className={`mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm ${
                    errors['rent_preferences.max_rent_duration_level'] ? 'border-red-500' : ''
                  }`}
                >
                  <option value="">Select...</option>
                  <option value="1">Level 1</option>
                  <option value="2">Level 2</option>
                  <option value="3">Level 3</option>
                  <option value="4">Level 4</option>
                  <option value="5">Level 5</option>
                </select>
                {errors['rent_preferences.max_rent_duration_level'] && <p className="mt-1 text-sm text-red-600">{errors['rent_preferences.max_rent_duration_level']}</p>}
            </div>

            {/* room_sharing_level (select) - Add this block */}
            <div>
                <label htmlFor="room_sharing_level" className="block text-sm font-medium text-gray-700">
                  Room Sharing Level
                </label>
                <select
                  id="room_sharing_level"
                  value={formState.rent_preferences.room_sharing_level ?? ''} // Use ?? '' to handle null
                  onChange={(e) => updateFormState('rent_preferences', 'room_sharing_level', e.target.value ? Number(e.target.value) as 1 | 2 | 3 : null)} // Assuming 1 | 2 | 3 based on API spec for rent_preferences
                  className={`mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm ${
                    errors['rent_preferences.room_sharing_level'] ? 'border-red-500' : ''
                  }`}
                >
                  <option value="">Select...</option>
                  <option value="1">Private Room Only</option>
                  <option value="2">Shared Room Possible</option>
                  <option value="3">Flexible (Any Arrangement)</option>
                </select>
                {errors['rent_preferences.room_sharing_level'] && <p className="mt-1 text-sm text-red-600">{errors['rent_preferences.room_sharing_level']}</p>}
            </div>
            {/* End of room_sharing_level field */}

            {/* Add Location Search Component */}
            <div>
                <label className="block text-sm font-medium text-gray-700">
                  Locations (Select up to 30, no overlaps)
                </label>
                <Locations
                    selectedLocations={formState.rent_preferences.locations as string[]} 
                    onLocationsChange={(newLocations) => updateFormState('rent_preferences', 'locations', newLocations)}
                    error={locationsApiError || errors['rent_preferences.locations']} // Pass error from main validator or specific API error
                    onClearError={clearLocationsApiError} // Pass function to clear the specific API error
                />
            </div>
            {/* End of Location Search Component */}
          </div>
        )
      default:
        return <div>Unknown Step</div>
    }
  }


  // --- RENDER ---
  return (
    <div className="min-h-screen bg-gradient-to-br from-background-white to-primary-blue flex flex-col items-center justify-center p-4">
      <div className="max-w-2xl w-full bg-white rounded-xl shadow-md p-8 space-y-6">
        <h1 className="text-2xl font-bold text-center text-black">Set Up Your Profile</h1>

        {/* Progress Bar/Steps Indicator */}
        <div className="mb-6">
          <nav aria-label="Progress">
            <ol className="flex items-center space-x-4">
              {STEPS.map((step, index) => (
                <li key={step.name} className="relative md:flex-1 md:flex">
                  {index < currentStep ? (
                    <div className="group flex w-full">
                      <span className="flex items-center text-sm font-medium text-gray-900">
                        {step.name}
                      </span>
                    </div>
                  ) : index === currentStep ? (
                    <div className="flex items-center" aria-current="step">
                      <span className="flex items-center text-sm font-medium text-indigo-600">
                        {step.name}
                      </span>
                    </div>
                  ) : (
                    <div className="group flex w-full">
                      <span className="flex items-center text-sm font-medium text-gray-500">
                        {step.name}
                      </span>
                    </div>
                  )}
                  {index !== STEPS.length - 1 ? (
                    <div className="absolute top-0 right-0 h-0 w-5 hidden md:block">
                      <svg
                        className="h-full w-full text-gray-300"
                        viewBox="0 0 22 80"
                        fill="none"
                        preserveAspectRatio="none"
                      >
                        <path
                          d="M0 -2L20 40L0 82"
                          vectorEffect="non-scaling-stroke"
                          stroke="currentcolor"
                          strokeLinejoin="round"
                        />
                      </svg>
                    </div>
                  ) : null}
                </li>
              ))}
            </ol>
          </nav>
        </div>

        {/* General Error Display (for validation or API errors) */}
        {generalError && ( // Or {apiError && ...} if you keep them separate
          <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded relative" role="alert">
            <span className="block sm:inline">Error: {generalError}</span> {/* Or "API Error: {apiError}" */}
          </div>
        )}

        {/* API Error Display */}
        {apiError && (
          <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded relative" role="alert">
            <span className="block sm:inline">API Error: {apiError}</span>
          </div>
        )}

        {/* Step Content */}
        {getStepContent()}

        {/* Navigation Buttons */}
        <div className="flex justify-between mt-8">
          <button
            type="button"
            onClick={prevStep}
            disabled={currentStep === 0}
            className={`px-4 py-2 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 ${
              currentStep === 0 ? 'opacity-50 cursor-not-allowed' : ''
            }`}
          >
            Back
          </button>
          {currentStep < STEPS.length - 1 ? (
            <button
              type="button"
              onClick={nextStep}
              className="ml-3 px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
            >
              Next
            </button>
          ) : (
            <button
              type="button"
              onClick={handleSubmit}
              disabled={isLoading}
              className={`ml-3 px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white ${
                isLoading ? 'bg-gray-400' : 'bg-green-600 hover:bg-green-700'
              } focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500`}
            >
              {isLoading ? 'Creating Profile...' : 'Create Profile'}
            </button>
          )}
        </div>
      </div>
    </div>
  )
}

_____________________________

shallwe_frontend/src/app/globals.css:

@import "tailwindcss";


@theme {
  /* Define custom colors as CSS custom properties */
  --color-brand-red: #FF0000;
  --color-black: #000000;
  --color-gray: #333333;
  --color-primary-blue: #ADD8E6;
  --color-primary-blue-dark: #87CEEB;
  --color-background-white: #FFFFFF;
}


/* Include the Tailwind layers */
@layer base, components, utilities;

_____________________________

shallwe_frontend/src/app/layout.tsx:

import '@/app/globals.css'
import type { Metadata } from 'next'
import { Inter } from 'next/font/google'

import Header from '@/app/components/layout/Header'
import Footer from '@/app/components/layout/Footer'

import { MSWInitializer } from '@/app/components/mock/MSWInit'
import { env } from '@/config/env'


const inter = Inter({ subsets: ['latin'] })


export const metadata: Metadata = {
  title: 'Shallwe - Find Your Flatmate',
  description: 'Connect with compatible flatmates.',
}


export default function RootLayout({children,}: {children: React.ReactNode}) {
  const useMocks = env.NEXT_PUBLIC_SHALLWE_MOCK_API

  return (
    <html lang="en">
      <body className={inter.className}>
        <div className="flex flex-col min-h-screen">
          <Header />
          <main className="flex-grow">
            {useMocks ? <MSWInitializer>{children}</MSWInitializer> : children}
          </main>
          <Footer />
        </div>
      </body>
    </html>
  )
}

_____________________________

shallwe_frontend/src/app/page.tsx:

'use client'


import { useState, useEffect, useRef } from 'react'

import { env } from '@/config/env'
import { ApiError } from '@/lib/shallwe/common/api/calls'
import { loginGoogle } from '@/lib/shallwe/auth/api/calls'


export default function LandingPage() {

  const [isLoading, setIsLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const authRequestSent = useRef(false)


  const openGoogleLogin = () => {
    const clientId = env.NEXT_PUBLIC_SHALLWE_OAUTH_CLIENT_ID
    if (!clientId) {
      console.error("NEXT_PUBLIC_GOOGLE_CLIENT_ID is not set in environment variables.")
      setError("Authentication configuration error. Please contact support.")
      return
    }

    const redirectUri = typeof window !== 'undefined' ? env.NEXT_PUBLIC_SHALLWE_OAUTH_REDIRECT_URI : 'http://localhost:3000' // Fallback for SSR
    const googleAuthUrl = `https://accounts.google.com/o/oauth2/v2/auth?redirect_uri=${encodeURIComponent(redirectUri)}&prompt=consent&response_type=code&client_id=${clientId}&scope=openid%20email%20profile`

    window.location.href = googleAuthUrl
  }


  const handleBackendAuth = async (code: string) => {
    try {
      await loginGoogle(code)
      console.log("Login successful via API call.")
      handleAuthSuccess()
    }
    catch (error) {
      handleAuthError(error)
    }
  } 


  const handleAuthSuccess = () => {
    setIsLoading(false)
    setError(null)
    window.location.reload()  // Middleware will handle the redirect based on profile-status
  }


  const handleAuthError = (err: unknown) => {
    const isApiError = (error: any): error is ApiError => {
      return error && typeof error === 'object' && 'message' in error
    }

    setIsLoading(false)
    console.error("Login error:", err)

    if (isApiError(err)) {
      setError(err.message || "An error occurred during login.")
    }
    else if (err instanceof Error) {
      setError(err.message)
    }
    else {
      console.warn("Unexpected error type received in handleLoginError:", typeof err, err)
      setError("An unexpected error occurred.")
    }
  }


  // Effect to check for code and finish auth flow after redirect back from Google
  useEffect(() => {
    if (typeof window === 'undefined') return

    const handleHomeLoad = async () => {
      const urlParams = new URLSearchParams(window.location.search)
      const code = urlParams.get('code')
      const errorParam = urlParams.get('error')

      if (errorParam) {
        console.error(`Google OAuth error: ${errorParam}`)
        setError(`Google OAuth error: ${errorParam}`)
        return // Stop further processing
      }

      if (code && !authRequestSent.current) {
        const decodedCode = decodeURIComponent(code)
        console.log("Received authorization code from Google:", decodedCode)

        setIsLoading(true)
        setError(null) // Clear any previous errors

        // Remove code from urlparams and prevent subsequent requests
        const newUrl = window.location.origin + window.location.pathname
        window.history.replaceState({}, document.title, newUrl)
        authRequestSent.current = true 

        await handleBackendAuth(decodedCode)  // Authenticate with backend
      }
    }

    handleHomeLoad()
  }, []) // Empty dependency array means this effect runs once on mount


  // ==== RENDER ====
  return (
    <div className="min-h-screen bg-gradient-to-br from-background-white to-primary-blue flex flex-col items-center justify-center p-4">
      <div className="max-w-md w-full bg-white rounded-xl shadow-md p-8 space-y-6">
        <h1 className="text-3xl font-bold text-center text-brand-red">Find Your Perfect Flatmate</h1>
        <p className="text-center text-text-black">
          Connect with people who share your lifestyle and values.
        </p>

        {error && (
          <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded relative" role="alert">
            <span className="block sm:inline">{error}</span>
          </div>
        )}

        <div className="mt-6">
          <button
            onClick={openGoogleLogin}
            disabled={isLoading}
            className={`w-full flex justify-center items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white cursor-pointer ${
              isLoading ? 'bg-gray-400' : 'bg-red-600 hover:bg-red-700'
            } focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500`}
          >
            {isLoading ? 'Signing in...' : 'Sign in with Google'}
          </button>
        </div>

        {isLoading && (
          <div className="mt-4 text-center text-text-black">
            Processing login...
          </div>
        )}

        <div className="mt-8 text-center text-sm text-text-black">
          <p>By signing in, you agree to our Terms and Privacy Policy.</p>
        </div>
      </div>
    </div>
  )
}

_____________________________

shallwe_frontend/src/config/env.ts:

import { z } from "zod"


const booleanStringSchema = z.string()
  .refine(
    (value) => value === "true" || value === "false",
    { message: "Must be exactly 'true' or 'false'" }
  )
  .transform((value) => value === "true")


const oAuthCliendIdStringSchema = z.string()
  .min(28)
  .refine(
    (value) => value.endsWith(".apps.googleusercontent.com"),
    { message: "Must be a valid Google OAuth client ID ending with .apps.googleusercontent.com" }
  )


// Env schema and minimal validation
const envSchema = z.object({
  NEXT_PUBLIC_SHALLWE_ENV_MODE: z.string(),
  NEXT_PUBLIC_SHALLWE_API_BASE_URL_EXTERNAL: z.url(),
  NEXT_PUBLIC_SHALLWE_API_BASE_URL_INTERNAL: z.url(),
  NEXT_PUBLIC_SHALLWE_OAUTH_REDIRECT_URI: z.url(),
  NEXT_PUBLIC_SHALLWE_OAUTH_CLIENT_ID: oAuthCliendIdStringSchema,
  NEXT_PUBLIC_SHALLWE_SKIP_MIDDLEWARE: booleanStringSchema,
  NEXT_PUBLIC_SHALLWE_MOCK_API: booleanStringSchema,
  NEXT_PUBLIC_SHALLWE_MIDDLEWARE_COOKIES_SECURE: booleanStringSchema
})


// Linking the exact keys (not ".parse(process.env)" because won't be linked in the browser)
export const env = envSchema.parse({
  NEXT_PUBLIC_SHALLWE_ENV_MODE: process.env.NEXT_PUBLIC_SHALLWE_ENV_MODE,
  NEXT_PUBLIC_SHALLWE_API_BASE_URL_EXTERNAL: process.env.NEXT_PUBLIC_SHALLWE_API_BASE_URL_EXTERNAL,
  NEXT_PUBLIC_SHALLWE_API_BASE_URL_INTERNAL: process.env.NEXT_PUBLIC_SHALLWE_API_BASE_URL_INTERNAL,
  NEXT_PUBLIC_SHALLWE_OAUTH_REDIRECT_URI: process.env.NEXT_PUBLIC_SHALLWE_OAUTH_REDIRECT_URI,
  NEXT_PUBLIC_SHALLWE_OAUTH_CLIENT_ID: process.env.NEXT_PUBLIC_SHALLWE_OAUTH_CLIENT_ID,
  NEXT_PUBLIC_SHALLWE_SKIP_MIDDLEWARE: process.env.NEXT_PUBLIC_SHALLWE_SKIP_MIDDLEWARE,
  NEXT_PUBLIC_SHALLWE_MOCK_API: process.env.NEXT_PUBLIC_SHALLWE_MOCK_API,
  NEXT_PUBLIC_SHALLWE_MIDDLEWARE_COOKIES_SECURE: process.env.NEXT_PUBLIC_SHALLWE_MIDDLEWARE_COOKIES_SECURE
})


// Declare expected vars for TS (not enforcing)
declare global {
  namespace NodeJS {
    interface ProcessEnv extends z.infer<typeof envSchema> {}
  }
}

_____________________________

shallwe_frontend/src/lib/common/cookie.ts:

export const getDocumentCookie = (name: string): string | undefined => {
  if (typeof document === 'undefined') {
    console.warn(`${getDocumentCookie.name}: 'document' is not available (likely running on the server).`)
    return undefined
  }

  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  
  if (parts.length === 2) return parts.pop()?.split(';').shift()
}

_____________________________

shallwe_frontend/src/lib/shallwe/access/api/calls.ts:

import { ApiError, baseApiCall } from "@/lib/shallwe/common/api/calls"
import { ProfileStatusResponse } from "./schema"


// Profile status
export const getProfileStatus = async (serverCookies?: string): Promise<ProfileStatusResponse> => {
  try {
    await baseApiCall('access/profile-status/', {}, serverCookies)
    return { status: 200 }  // Authorized and profile exists
  }

  catch (error) {  // Catch expected (403/404), re-throw others
    const apiError = error as ApiError

    if ('status' in apiError) {
      if (apiError.status === 403) {
        return { status: 403 }  // Unauthorized
      }
      else if (apiError.status === 404) {
        return { status: 404 }  // Authorized, but no profile
      }
      else throw error  // Unexpected status - uknown error
    }
    else throw error  // No status - uknown error
  }
}

_____________________________

shallwe_frontend/src/lib/shallwe/access/api/schema.ts:

export interface ProfileStatusResponse {
  status: number   // 200, 403, 404
}

_____________________________

shallwe_frontend/src/lib/shallwe/auth/api/calls.ts:

import { baseApiCall } from '@/lib/shallwe/common/api/calls'


// Login
export const loginGoogle = async (code: string): Promise<{key: string}> => {
  return baseApiCall('auth/login/google/', {
    method: 'POST',
    body: { code } as any,
  })
}


// Logout
export const logout = async (): Promise<void> => {
  await baseApiCall('auth/logout/', {
    method: 'POST',
  })  // Note: The backend handles cookie invalidation. Frontend state cleanup is separate too.
}


// Delete user
export const deleteUser = async (): Promise<void> => {
  await baseApiCall('auth/user/', {
    method: 'DELETE',
  })
}

_____________________________

shallwe_frontend/src/lib/shallwe/common/api/calls.ts:

import { env } from '@/config/env'
import { getDocumentCookie } from '@/lib/common/cookie'


// --- HELPERS ---
export interface ApiError {
  message: string
  status?: number
  details?: any
}


// --- BASE API CALL FUNCTION (TO EXTEND) ---
export const baseApiCall = async (
  endpoint: string, options: RequestInit = {}, serverCookies?: string // Optional cookies string passed from server context (e.g., middleware)
): Promise<any> => {

  // Base config
  const { method = 'GET', headers = {}, body, ...restOptions } = options
  const url = `${env.NEXT_PUBLIC_SHALLWE_API_BASE_URL_EXTERNAL}/api/rest/${endpoint}`

  const baseHeaders: Record<string, string> = {
    'Content-Type': 'application/json',  // Default, can be overridden
    ...(headers as Record<string, string>),  // Allow overriding defaults
  }

  // CSRF-token header
  let csrfToken: string | undefined = undefined

  if (!serverCookies && typeof window !== 'undefined') {
    csrfToken = getDocumentCookie('csrftoken')
  }

  if (csrfToken) {
    baseHeaders['X-CSRFToken'] = csrfToken
  }
  if (serverCookies) {
    baseHeaders['Cookie'] = serverCookies;
  }

  // Content-Type specific config
  let finalBody = body
  if (body) {
    if (body instanceof FormData) {
      delete baseHeaders['Content-Type']  // Browser will set it correctly with the boundary
    }
    else {
      finalBody = JSON.stringify(body)
    }
  }

  // API call logic
  try {
    const fetchOptions: RequestInit = {
      method,
      headers: baseHeaders,
      body: finalBody,
      ...restOptions,
    }

    if (!serverCookies) {
      fetchOptions.credentials = 'include' // Crucial for client-side: Include sessionid and csrftoken cookies
    }

    const response = await fetch(url, fetchOptions)

    // Handle HTTP errors
    if (!response.ok) {
      let errorData: any = { message: `HTTP Error: ${response.status} ${response.statusText}` }

      if (response.headers.get('content-type')?.includes('application/json')) {
        try {
          errorData = await response.json()
        }
        catch (e) {
          console.warn('Could not parse error response as JSON: ', e)
        }
      }

      const apiError: ApiError = {
        message: errorData.message || `HTTP Error: ${response.status}`,
        status: response.status,
        details: errorData,
      }
      throw apiError
    }

    return response.text().then(text => text ? JSON.parse(text) : null)  // Avoid error when body is empty
  }

  // Handle runtime errors (ours included)
  catch (error) {
    console.error(`API call failed for ${method} ${url}:`, error)

    if ((error as ApiError).message) {  // It's our defined error
      throw error
    }
    else {  // It's likely an unexpected error
      throw new Error(`Network or unexpected error during API call to ${url}: ${(error as Error).message}`)
    }
  }
}

_____________________________

shallwe_frontend/src/lib/shallwe/common/api/schema.ts:

// --- API Error Response Type ---
export interface ApiErrorResponse {
  error?: string | Record<string, any>  // Can be a simple string or a structured object like {profile: {name: ["error"]}}
}

_____________________________

shallwe_frontend/src/lib/shallwe/common/api/typeGuards.ts:

import { ApiError } from '@/lib/shallwe/common/api/calls'


export const isApiError = (error: any): error is ApiError => {
  return (
    error &&
    typeof error === 'object' &&
    'message' in error
  )
}

_____________________________

shallwe_frontend/src/lib/shallwe/locations/api/calls.ts:

import { ApiError, baseApiCall } from "@/lib/shallwe/common/api/calls"
import { emptyLocationsReadData, LocationsReadFields } from "./schema"


// Search locations
export const searchLocations = async (query: string): Promise<LocationsReadFields> => {
  const params = new URLSearchParams({ query })
  // try {
    return baseApiCall(`locations/search/?${params}`) as Promise<LocationsReadFields>
//   }
//   catch (error) {
//     console.log((error as ApiError).status)
//     const apiError = error as ApiError
//     if ('status' in apiError && apiError.status === 404) {
//       return Promise.resolve(emptyLocationsReadData)
//     }
//     else throw error
//   }
}

_____________________________

shallwe_frontend/src/lib/shallwe/locations/api/schema.ts:

interface RegionReadFields {
  hierarchy: string
  region_name: string
}


interface CityReadFields {
  hierarchy: string
  region_name: string
  ppl_name: string
  districts: DistrictReadFields[]
}


interface DistrictReadFields {
  hierarchy: string
  district_name: string
}


interface OtherPplReadFields {
  hierarchy: string
  region_name: string
  subregion_name: string
  ppl_name: string
}


export interface GenericLocationReadFields {  // For iterating over different types of locations
  hierarchy: string
  region_name?: string
  subregion_name?: string
  ppl_name?: string
  district_name?: string
  districts?: DistrictReadFields[]
}


export interface LocationsReadFields {
  regions: RegionReadFields[]
  cities: CityReadFields[]
  other_ppls: OtherPplReadFields[]
}


export const emptyLocationsReadData: LocationsReadFields = {
  regions: [],
  cities: [],
  other_ppls: []
}

_____________________________

shallwe_frontend/src/lib/shallwe/photo/api/calls.ts:

import { baseApiCall } from "@/lib/shallwe/common/api/calls"


// Perform facecheck
export const performFacecheck = async (imageFile: File): Promise<any> => {
  const formData = new FormData()
  formData.append('image', imageFile)

  return baseApiCall('photo/facecheck/', {
    method: 'POST',
    body: formData,
  })
}

_____________________________

shallwe_frontend/src/lib/shallwe/photo/formstates/validators.ts:

export const MAX_PHOTO_FILE_SIZE = 20 * 1024 * 1024  // 20 MB
export const ALLOWED_IMAGE_TYPES = ['image/jpeg', 'image/jpg', 'image/png', 'image/heic', 'image/heif']


export const validateProfilePhotoFile = (value: File) => {
  if (!ALLOWED_IMAGE_TYPES.includes(value!.type.toLowerCase())) {
    return 'Photo must be JPG, JPEG, PNG, HEIC, or HEIF.'
  }
  if (value!.size > MAX_PHOTO_FILE_SIZE) return 'Photo file size must be under 20MB.'
  return null
}

_____________________________

shallwe_frontend/src/lib/shallwe/profile/api/schema/common.ts:

export interface AboutBaseFields {
  birth_date: string  // YYYY-MM-DD
  gender: 1 | 2  // m | f
  is_couple: boolean
  has_children: boolean
  occupation_type: 1 | 2 | 3 | 4 | null
  drinking_level: 1 | 2 | 3 | 4 | null
  smoking_level: 1 | 2 | 3 | 4 | null
  smokes_iqos: boolean
  smokes_vape: boolean
  smokes_tobacco: boolean
  smokes_cigs: boolean
  neighbourliness_level: 1 | 2 | 3 | null
  guests_level: 1 | 2 | 3 | null
  parties_level: 1 | 2 | 3 | null
  bedtime_level: 1 | 2 | 3 | 4 | null
  neatness_level: 1 | 2 | 3 | null
  has_cats: boolean
  has_dogs: boolean
  has_reptiles: boolean
  has_birds: boolean
  other_animals: string[]  // Up to 5 strings
  interests: string[]  // Up to 5 strings
  bio: string | null  // Up to 1024 chars
}


export interface RentPreferencesBaseFields {
  min_budget: number
  max_budget: number
  min_rent_duration_level: number
  max_rent_duration_level: number
  room_sharing_level: number
}

_____________________________

shallwe_frontend/src/lib/shallwe/profile/api/schema/create.ts:

import { AboutBaseFields, RentPreferencesBaseFields } from "./common"


export interface ProfileCreateProfileFields {
  name: string
  photo: File
}


export interface LocationsCreateFields {
  locations?: string[]
}


export interface ProfileCreateData {
  profile: ProfileCreateProfileFields

  about: {
    birth_date: string  // YYYY-MM-DD
    gender: 1 | 2
    is_couple: boolean
    has_children: boolean
  } & Partial<Omit<AboutBaseFields, 'birth_date' | 'gender' | 'is_couple' | 'has_children'>>  // Other optional fields

  rent_preferences: {
    min_budget: number
    max_budget: number
  } & Partial<Omit<RentPreferencesBaseFields, 'min_budget' | 'max_budget'>> // Other optional fields
    & LocationsCreateFields
}

_____________________________

shallwe_frontend/src/lib/shallwe/profile/api/schema/read.ts:

import { LocationsReadFields } from "@/lib/shallwe/locations/api/schema"
import { AboutBaseFields, RentPreferencesBaseFields } from "./common"


export interface ProfileProfileReadFields {
    is_hidden: boolean
    name: string
    photo_w768: string  // Photo url in different sizes (per specific usages)
    photo_w540: string
    photo_w192: string
    photo_w64: string
}


export interface ProfileReadData {
  profile: ProfileProfileReadFields
  rent_preferences: RentPreferencesBaseFields & {
    locations: LocationsReadFields
  }
  about: AboutBaseFields
}

_____________________________

shallwe_frontend/src/lib/shallwe/profile/api/schema/update.ts:

import { ProfileCreateData } from "./create"


// Same as create, but all optional
// (cherry-pick changes allowed, except required combinations - checked during validation)
export interface ProfileUpdateData {
  profile?: Partial<ProfileCreateData['profile']>
  about?: Partial<ProfileCreateData['about']>
  rent_preferences?: Partial<ProfileCreateData['rent_preferences']>
}

_____________________________

shallwe_frontend/src/lib/shallwe/profile/api/calls.ts:

import { baseApiCall } from "@/lib/shallwe/common/api/calls"
import { ProfileCreateData } from "./schema/create"
import { ProfileUpdateData } from "./schema/update"
import { formatMultipartFormData } from "./multipart"


// Read profile
export const getProfile = async (): Promise<any> => {
  return baseApiCall('profile/me/')
}


// Create profile
export const createProfile = async (profileData: ProfileCreateData): Promise<any> => {
  const formData = formatMultipartFormData(profileData)

  return baseApiCall('profile/me/', {
    method: 'POST',
    body: formData,
  })
}


// Update profile
export const updateProfile = async (profileData: ProfileUpdateData): Promise<any> => {
  const formData = formatMultipartFormData(profileData)
  formData.entries().forEach((pair) => console.log(pair[0], ':', pair[1]))

  return baseApiCall('profile/me/', {
    method: 'PATCH',
    body: formData,
  })
}


// Update profile visibility
export const updateProfileVisibility = async (isHidden: boolean): Promise<any> => {
  return baseApiCall('profile/visibility/', {
    method: 'PATCH',
    body: { is_hidden: isHidden } as any,
  })
}

_____________________________

shallwe_frontend/src/lib/shallwe/profile/api/multipart.ts:

import { ProfileCreateData } from "./schema/create"
import { ProfileUpdateData } from "./schema/update"


/** Converts JSON-like data object into the multipart format that backend expects
* 
*   Rules:
*   - group__field -> simple field key
*   - group__field[] -> list field key
*   - string 'null' for nulls
*/
export const formatMultipartFormData = (data: ProfileCreateData | ProfileUpdateData): FormData => {
  const formData = new FormData()

  const parseParamGroup = (groupName: keyof (ProfileCreateData | ProfileUpdateData)) => {
    const groupData: Record<string, any> | undefined = data[groupName]

    if (!groupData) return

    Object.entries(groupData).forEach(([key, value]) => {
      const baseKey = `${groupName}__${key}`
      const appendValue = (value: any, key?: string) => formData.append(key ? key : baseKey, value)
      
      if (value !== undefined) {
        if (value === null) appendValue('null')  // Make nulls backend-friendly
        else if (value instanceof File) appendValue(value)  // Handle Files as is
        else if (Array.isArray(value)) {
          const listKey = `${baseKey}[]`
          if (value.length === 0) appendValue('', listKey)  // Handle empty lists -> backend expects [] marker
          else value.forEach(item => appendValue(item, listKey))
        }
        else appendValue(value.toString())  // Stringify the rest
      }
    })
  }

  (Object.keys(data) as Array<keyof (ProfileCreateData | ProfileUpdateData)>).forEach(groupName => {
    parseParamGroup(groupName)
  })

  return formData
}

_____________________________

shallwe_frontend/src/lib/shallwe/profile/formstates/collectors/create.ts:

import { ProfileCreateData } from "../../api/schema/create"
import { ProfileCreateFormState } from "../states"


// This function basically assures that we are collecting state correctly as per API data requirements
// Check that required fields are in place, omit sending optional as nulls
export function collectProfileCreateDataFromState(formState: ProfileCreateFormState): ProfileCreateData {
  // Validate required fields
  const requiredChecks = [
    { value: formState.profile.name, field: 'name' },
    { value: formState.profile.photo, field: 'photo' },
    { value: formState.about.birth_date, field: 'birth_date' },
    { value: formState.about.gender, field: 'gender' },
    { value: formState.about.is_couple, field: 'is_couple' },
    { value: formState.about.has_children, field: 'has_children' },
    { value: formState.rent_preferences.min_budget, field: 'min_budget' },
    { value: formState.rent_preferences.max_budget, field: 'max_budget' },
  ]

  const missingRequiredField = requiredChecks.find(check => check.value === null)
  if (missingRequiredField) {
    throw new Error(`${missingRequiredField.field} is required for creation`)
  }

  // Helper to filter out nulls from non-required fields
  const filterNonNullOptionalValues = <T extends Record<string, any>>(obj: T, requiredKeys: string[]): Partial<T> => {
    const result: Partial<T> = {}
    Object.entries(obj).forEach(([key, value]) => {
      if (value !== null && !requiredKeys.includes(key)) {
        (result as any)[key] = value
      }
    })
    return result
  }

  return {
    profile: {
      name: formState.profile.name!,
      photo: formState.profile.photo!,
    },
    about: {
      birth_date: formState.about.birth_date!,
      gender: formState.about.gender!,
      is_couple: formState.about.is_couple!,
      has_children: formState.about.has_children!,
      ...filterNonNullOptionalValues(
        formState.about, ['birth_date', 'gender', 'is_couple', 'has_children']
      ) as Partial<Omit<ProfileCreateData['about'], 'birth_date' | 'gender' | 'is_couple' | 'has_children'>>,
    },
    rent_preferences: {
      min_budget: formState.rent_preferences.min_budget!,
      max_budget: formState.rent_preferences.max_budget!,
      ...filterNonNullOptionalValues(
        formState.rent_preferences, ['min_budget', 'max_budget']
      ) as Partial<Omit<ProfileCreateData['rent_preferences'], 'min_budget' | 'max_budget'>>,
    }
  }
}

_____________________________

shallwe_frontend/src/lib/shallwe/profile/formstates/collectors/update.ts:

import { LocationsReadFields } from "@/lib/shallwe/locations/api/schema";
import { ProfileReadData } from "../../api/schema/read";
import { ProfileUpdateData } from "../../api/schema/update";
import { ProfileUpdateFormState } from "../states";

// Helper function to convert LocationsReadFields object to an array of hierarchy strings
export const extractHierarchyStrings = (locationsObject: LocationsReadFields): string[] => {
  const hierarchies: string[] = [];
  if (locationsObject.regions) {
    hierarchies.push(...locationsObject.regions.map(r => r.hierarchy));
  }
  if (locationsObject.cities) {
    locationsObject.cities.forEach(c => {
      const districtHierarchies = c.districts?.map(d => d.hierarchy) || [];
      if (districtHierarchies.length > 0) {
        // Rule: If a city has selected districts, only add the district hierarchies
        hierarchies.push(...districtHierarchies);
      } else {
        // Rule: If a city has no selected districts, add the city's own hierarchy
        hierarchies.push(c.hierarchy);
      }
    });
  }
  if (locationsObject.other_ppls) {
    hierarchies.push(...locationsObject.other_ppls.map(op => op.hierarchy));
  }
  return hierarchies;
};

// Helper function to compare two simple values (primitives, arrays of primitives, null/undefined)
function valuesAreEqual(value1: any, value2: any): boolean {
  if (value1 === value2) return true;
  if (value1 == null && value2 == null) return true; // Handles both being null
  if (Array.isArray(value1) && Array.isArray(value2)) {
    if (value1.length !== value2.length) return false;
    for (let i = 0; i < value1.length; i++) {
      if (value1[i] !== value2[i]) return false;
    }
    return true;
  }
  return false;
}

// This function compares the editFormState with the initialProfileData to collect only changed values
export function collectProfileUpdateDataFromState(
  formState: ProfileUpdateFormState,
  initialProfileData: ProfileReadData
): ProfileUpdateData {
  const updatePayload: ProfileUpdateData = {};

  // --- Profile Section ---
  const updateProfile: Partial<ProfileUpdateData['profile']> = {};

  // Handle name: compare, if changed, assign the state value (which is string).
  if (formState.profile.name !== initialProfileData.profile.name) {
    updateProfile.name = formState.profile.name; // Assigns string
  }

  // Handle photo: File object means change, assign it. Null means no change intended, omit.
  if (formState.profile.photo instanceof File) {
    updateProfile.photo = formState.profile.photo; // Include the new File
  }

  if (Object.keys(updateProfile).length > 0) {
    updatePayload.profile = updateProfile;
  }

  // --- About Section ---
  const updateAbout: Partial<ProfileUpdateData['about']> = {};

  // Handle all fields in about section
  for (const key of Object.keys(formState.about) as (keyof ProfileUpdateFormState['about'])[]) {
    const stateValue = formState.about[key];
    const initialValue = (initialProfileData.about as any)[key];

    if (!valuesAreEqual(stateValue, initialValue)) {
      // For fields that are T | null in state (like bio, levels), assign directly.
      // For fields that are T (like booleans, numbers) in state, assign directly.
      // The payload type will determine if null is allowed or not at the API level.
      (updateAbout as any)[key] = stateValue;
    }
  }

  if (Object.keys(updateAbout).length > 0) {
    updatePayload.about = updateAbout;
  }

  // --- Rent Preferences Section ---
  const updateRentPrefs: Partial<ProfileUpdateData['rent_preferences']> = {};

  // Handle all fields in rent_preferences section
  for (const key of Object.keys(formState.rent_preferences) as (keyof ProfileUpdateFormState['rent_preferences'])[]) {
    if (key === 'locations') {
      // Compare locations array (converted from initial object)
      const initialLocationsArray = extractHierarchyStrings(initialProfileData.rent_preferences.locations);
      if (!valuesAreEqual(formState.rent_preferences.locations, initialLocationsArray)) {
        updateRentPrefs.locations = formState.rent_preferences.locations; // Assigns string[]
      }
    } else {
      // Compare other fields (numbers)
      const stateValue = formState.rent_preferences[key];
      const initialValue = (initialProfileData.rent_preferences as any)[key];

      if (!valuesAreEqual(stateValue, initialValue)) {
        (updateRentPrefs as any)[key] = stateValue; // Assigns number
      }
    }
  }

  if (Object.keys(updateRentPrefs).length > 0) {
    updatePayload.rent_preferences = updateRentPrefs;
  }

  return updatePayload;
}
_____________________________

shallwe_frontend/src/lib/shallwe/profile/formstates/validators/common.ts:

import { validateProfilePhotoFile } from "@/lib/shallwe/photo/formstates/validators"
import { ProfileCreateFormState } from "../states"


export const getNestedValue = (obj: any, path: string): any => {
  return path.split('.').reduce((current, key) => current?.[key], obj)
}


export interface ValidationResult {
  isValid: boolean
  errors: Record<string, string>
}


export const isEmptyValue = (value: any): boolean => {
  return value === null || value === undefined || value === '' || (Array.isArray(value) && value.length === 0)
}


const getAge = (birthDate: Date): number => {
  const today = new Date()
  let age = today.getFullYear() - birthDate.getFullYear()
  const monthDiff = today.getMonth() - birthDate.getMonth()
  if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birthDate.getDate())) {
    age--
  }
  return age
}


export const RU_UA_CHARS = /^[–∞-—è–ê-–Ø—ë–Å—ñ–Ü—ó–á—î–Ñ“ë“ê'`]+$/u
export const RU_UA_CHARS_WITH_HYPHEN = /^[–∞-—è–ê-–Ø—ë–Å—ñ–Ü—ó–á—î–Ñ“ë“ê\-`]+$/u
export const RU_UA_CHARS_WITH_SPACE = /^[–∞-—è–ê-–Ø—ë–Å—ñ–Ü—ó–á—î–Ñ“ë“ê\s\-`]+$/u


type ProfileFieldValidator = (value: any, formData: ProfileCreateFormState) => string | null


interface StringListValidationConfig {
  maxItems: number
  itemName: string
  minLength?: number
  maxLength?: number
  pattern?: RegExp
  patternError?: string
}


export const createStringListValidator = (config: StringListValidationConfig): ProfileFieldValidator => {
  return (value: string[] | null) => {
    if (!Array.isArray(value)) return `${config.itemName} must be a list, not ${typeof value}.`
    if (value.length === 0) return null // Empty list is a legit value
    
    if (value!.length > config.maxItems) {
      return `${config.itemName} list must have up to ${config.maxItems} items.`
    }
    
    const uniqueItems = new Set(value!)
    if (uniqueItems.size !== value!.length) {
      return `${config.itemName} list must have unique items.`
    }
    
    if (config.minLength || config.maxLength || config.pattern) {
      for (const item of value!) {
        if (config.pattern && !config.pattern.test(item)) {
          return config.patternError || `Some of ${config.itemName.toLowerCase()} have invalid format.`
        }
        if (config.minLength && config.maxLength) {
          if (item.length < config.minLength || item.length > config.maxLength) {
            return `Each ${config.itemName.toLowerCase()} must be between ${config.minLength} and ${config.maxLength} characters.`
          }
        }
      }
    }
    
    return null
  }
}


export const validators: Record<string, ProfileFieldValidator> = {

  'profile.name': (value: string | null) => {
    if (isEmptyValue(value)) return 'Name is required.'
    if (value!.length < 2 || value!.length > 16) return 'Name must be between 2 and 16 characters.'
    if (!RU_UA_CHARS.test(value!)) return 'Name must contain only RU/UA characters, apostrophe, or backtick.'
    return null
  },

  'profile.photo': (value: File | null) => {
    if (isEmptyValue(value)) return 'Photo is required.'
    else return validateProfilePhotoFile(value!)
  },

  'about.birth_date': (value: string | null) => {
    if (isEmptyValue(value)) return 'Birth date is required.'
    const age = getAge(new Date(value!))
    if (age < 16 || age > 120) return 'Age must be between 16 and 120.'
    return null
  },

  'about.gender': (value: number | null) => {
    if (isEmptyValue(value)) return 'Gender is required.'
    return null
  },

  'about.is_couple': (value: boolean | null) => {
    if (isEmptyValue(value)) return 'Is couple status is required.'
    return null
  },

  'about.has_children': (value: boolean | null) => {
    if (isEmptyValue(value)) return 'Has children status is required.'
    return null
  },

  'about.smoking_level': (value: number | null, formData: ProfileCreateFormState) => {
    if (value !== null && value !== undefined) {
      const hasSmokingType = formData.about.smokes_iqos || formData.about.smokes_vape || 
                             formData.about.smokes_tobacco || formData.about.smokes_cigs
      if (!hasSmokingType && value > 1) {
        return 'If smoking level is greater than 1, at least one smoking type must be selected.'
      }
      if (hasSmokingType && value <= 1) {
        return 'If smoking level is less than or equal to 1, none of smoking types can be selected.'
      }
    }
    return null
  },

  'about.smokes_iqos': (value: boolean | null) => {
    if (value === null || value === undefined) return 'Smokes IQOS field cannot be unset'
    return null
  },

  'about.smokes_vape': (value: boolean | null) => {
    if (value === null || value === undefined) return 'Smokes vape field cannot be unset'
    return null
  },

  'about.smokes_tobacco': (value: boolean | null) => {
    if (value === null || value === undefined) return 'Smokes tobacco field cannot be unset'
    return null
  },

  'about.smokes_cigs': (value: boolean | null) => {
    if (value === null || value === undefined) return 'Smokes cigarettes field cannot be unset'
    return null
  },

  'about.has_cats': (value: boolean | null) => {
    if (value === null || value === undefined) return 'Has cats field cannot be unset'
    return null
  },

  'about.has_dogs': (value: boolean | null) => {
    if (value === null || value === undefined) return 'Has dogs field cannot be unset'
    return null
  },

  'about.has_reptiles': (value: boolean | null) => {
    if (value === null || value === undefined) return 'Has reptiles field cannot be unset'
    return null
  },

  'about.has_birds': (value: boolean | null) => {
    if (value === null || value === undefined) return 'Has birds field cannot be unset'
    return null
  },

  'about.other_animals': createStringListValidator({
    maxItems: 5,
    itemName: 'Other animals',
    minLength: 2,
    maxLength: 32,
    pattern: RU_UA_CHARS_WITH_HYPHEN,
    patternError: 'Each animal name must contain only RU/UA characters, hyphen, or backtick.'
  }),

  'about.interests': createStringListValidator({
    maxItems: 5,
    itemName: 'Interests',
    minLength: 2,
    maxLength: 32,
    pattern: RU_UA_CHARS_WITH_SPACE,
    patternError: 'Each interest must contain only RU/UA characters, space, hyphen, or backtick.'
  }),

  'about.bio': (value: string | null) => {
    if (isEmptyValue(value)) return null
    if (value!.length > 1024) return 'Bio must be up to 1024 characters.'
    return null
  },

  'rent_preferences.min_budget': (value: number | null) => {
    if (isEmptyValue(value)) return 'Min budget is required.'
    if (value! < 0 || value! > 99999) return 'Min budget must be between 0 and 99999.'
    return null
  },

  'rent_preferences.max_budget': (value: number | null) => {
    if (isEmptyValue(value)) return 'Max budget is required.'
    if (value! < 0 || value! > 99999) return 'Max budget must be between 0 and 99999.'
    return null
  },

  'rent_preferences.min_rent_duration_level': (value: number | null) => {
    if (value === null || value === undefined) return 'Min rent duration level field cannot be unset'
    return null
  },

  'rent_preferences.max_rent_duration_level': (value: number | null) => {
    if (value === null || value === undefined) return 'Max rent duration level field cannot be unset'
    return null
  },

  'rent_preferences.room_sharing_level': (value: number | null) => {
    if (value === null || value === undefined) return 'Room sharing level field cannot be unset'
    return null
  },

  'rent_preferences.locations': createStringListValidator({
    maxItems: 30,
    itemName: 'Locations'
  })
}


export const validateProfileCrossFieldRules = (
  formData: ProfileCreateFormState,
  fieldsToValidate: string[]
): Record<string, string> => {
  const errors: Record<string, string> = {}

  // Budget relationship - show error on max_budget field
  if (fieldsToValidate.includes('rent_preferences.min_budget') || 
      fieldsToValidate.includes('rent_preferences.max_budget')) {
    const { min_budget, max_budget } = formData.rent_preferences
    if (min_budget !== null && max_budget !== null && min_budget > max_budget) {
      errors['rent_preferences.max_budget'] = 'Max budget must be greater than or equal to min budget.'
    }
  }

  // Duration relationship - show error on min_rent_duration_level field
  if (fieldsToValidate.includes('rent_preferences.min_rent_duration_level') || 
      fieldsToValidate.includes('rent_preferences.max_rent_duration_level')) {
    const { min_rent_duration_level, max_rent_duration_level } = formData.rent_preferences
    
    if ((min_rent_duration_level !== null && max_rent_duration_level === null) || 
        (min_rent_duration_level === null && max_rent_duration_level !== null)) {
      errors['rent_preferences.min_rent_duration_level'] = 'Both min and max duration levels must be provided together.'
    }
    else if (min_rent_duration_level !== null && max_rent_duration_level !== null && 
             min_rent_duration_level > max_rent_duration_level) {
      errors['rent_preferences.max_rent_duration_level'] = 'Max duration level must be greater than or equal to min duration level.'
    }
  }

  return errors
}

_____________________________

shallwe_frontend/src/lib/shallwe/profile/formstates/validators/create.ts:

import { ProfileCreateFormState } from '../states'
import { getNestedValue, validateProfileCrossFieldRules, ValidationResult, validators } from './common'


export const validateProfileCreateFields = (
  formState: ProfileCreateFormState, 
  fieldsToValidate: string[]
): ValidationResult => {
  const errors: Record<string, string> = {}

  // Validate individual fields
  for (const fieldPath of fieldsToValidate) {
    const validator = validators[fieldPath]
    if (validator) {
      const value = getNestedValue(formState, fieldPath)
      const error = validator(value, formState)
      if (error) {
        errors[fieldPath] = error
      }
    }
  }

  // Validate cross-field relationships
  const crossFieldErrors = validateProfileCrossFieldRules(formState, fieldsToValidate)
  Object.assign(errors, crossFieldErrors)

  return {
    isValid: Object.keys(errors).length === 0,
    errors
  }
}

_____________________________

shallwe_frontend/src/lib/shallwe/profile/formstates/validators/update.ts:

import { ProfileUpdateFormState } from '../states'
import { getNestedValue, validateProfileCrossFieldRules, ValidationResult, validators } from './common'


export const validateProfileUpdateFields = (
  formState: ProfileUpdateFormState,
  fieldsToValidate: string[]
): ValidationResult => {
  const errors: Record<string, string> = {}

  // Validate individual fields
  for (const fieldPath of fieldsToValidate) {
    if (fieldPath === 'profile.photo' && formState.profile.photo === null) continue

    const validator = validators[fieldPath]
    if (validator) {
      const value = getNestedValue(formState, fieldPath)
      const error = validator(value, formState)
      if (error) {
        errors[fieldPath] = error
      }
    }
  }

  // Validate cross-field relationships
  const crossFieldErrors = validateProfileCrossFieldRules(formState, fieldsToValidate)
  Object.assign(errors, crossFieldErrors)

  return {
    isValid: Object.keys(errors).length === 0,
    errors
  }
}

_____________________________

shallwe_frontend/src/lib/shallwe/profile/formstates/states.ts:

import { ProfileCreateData } from "../api/schema/create"
import { ProfileReadData } from "../api/schema/read"
import { extractHierarchyStrings } from "./collectors/update"


type UndefinedForbidden<T> = Exclude<T, undefined>


type ProfileCreateFormStateField<T> = 
  T extends any[] ? UndefinedForbidden<T> :
  UndefinedForbidden<T> | null


// For CreateFormState fields primitives are nullable (for initial)
// Undefined/optional is dropped everywhere to keep all fields explicitly tracked
type ProfileCreateFormStateFieldsRequired<T> = {
  [K in keyof T]-?: ProfileCreateFormStateField<T[K]>
}


export interface ProfileCreateFormState {
  profile: ProfileCreateFormStateFieldsRequired<ProfileCreateData['profile']>
  about: ProfileCreateFormStateFieldsRequired<ProfileCreateData['about']>
  rent_preferences: ProfileCreateFormStateFieldsRequired<ProfileCreateData['rent_preferences']>
}


// Initial State
export const profileCreateFormStateInitial: ProfileCreateFormState = {
  profile: {
    name: null,
    photo: null
  },
  about: {
    birth_date: null,
    gender: null,
    is_couple: false,
    has_children: false,
    occupation_type: null,
    drinking_level: null,
    smoking_level: null,
    smokes_iqos: null,
    smokes_vape: null,
    smokes_tobacco: null,
    smokes_cigs: null,
    neighbourliness_level: null,
    guests_level: null,
    parties_level: null,
    bedtime_level: null,
    neatness_level: null,
    has_cats: null,
    has_dogs: null,
    has_reptiles: null,
    has_birds: null,
    other_animals: [],
    interests: [],
    bio: null
  },
  rent_preferences: {
    min_budget: null,
    max_budget: null,
    min_rent_duration_level: null,
    max_rent_duration_level: null,
    room_sharing_level: null,
    locations: []
  }
}


// For CreateFormState fields primitives are nullable (for initial)
// Undefined/optional is dropped everywhere to keep all fields explicitly tracked
type ProfileUpdateFormStateFieldsRequired<T> = {
  [K in keyof T]-?: UndefinedForbidden<T[K]>
}


export interface ProfileUpdateFormState {
  profile: ProfileUpdateFormStateFieldsRequired<Omit<ProfileCreateData['profile'], 'photo'>> & {
    photo: File | null
  }
  about: ProfileUpdateFormStateFieldsRequired<ProfileCreateData['about']>
  rent_preferences: ProfileUpdateFormStateFieldsRequired<ProfileCreateData['rent_preferences']>
}


export const getProfileUpdateFormStateInitial = (initialProfileData: ProfileReadData): ProfileUpdateFormState => {
 // Initialize editFormState from initialProfileData
  // Required fields are pre-populated from profileData
  const profileUpdateFormStateInitial: ProfileUpdateFormState = {
    profile: {
      name: initialProfileData.profile.name,
      photo: null, // Initialize photo to null, meaning "no change intended". The cropper will show the existing photo URL.
    },
    about: {
      birth_date: initialProfileData.about.birth_date,
      gender: initialProfileData.about.gender,
      is_couple: initialProfileData.about.is_couple,
      has_children: initialProfileData.about.has_children,
      // Initialize other 'about' fields from profileData
      occupation_type: initialProfileData.about.occupation_type,
      drinking_level: initialProfileData.about.drinking_level,
      smoking_level: initialProfileData.about.smoking_level,
      smokes_iqos: initialProfileData.about.smokes_iqos,
      smokes_vape: initialProfileData.about.smokes_vape,
      smokes_tobacco: initialProfileData.about.smokes_tobacco,
      smokes_cigs: initialProfileData.about.smokes_cigs,
      neighbourliness_level: initialProfileData.about.neighbourliness_level,
      guests_level: initialProfileData.about.guests_level,
      parties_level: initialProfileData.about.parties_level,
      bedtime_level: initialProfileData.about.bedtime_level,
      neatness_level: initialProfileData.about.neatness_level,
      has_cats: initialProfileData.about.has_cats,
      has_dogs: initialProfileData.about.has_dogs,
      has_reptiles: initialProfileData.about.has_reptiles,
      has_birds: initialProfileData.about.has_birds,
      other_animals: initialProfileData.about.other_animals,
      interests: initialProfileData.about.interests,
      bio: initialProfileData.about.bio,
    },
    rent_preferences: {
      min_budget: initialProfileData.rent_preferences.min_budget,
      max_budget: initialProfileData.rent_preferences.max_budget,
      min_rent_duration_level: initialProfileData.rent_preferences.min_rent_duration_level,
      max_rent_duration_level: initialProfileData.rent_preferences.max_rent_duration_level,
      room_sharing_level: initialProfileData.rent_preferences.room_sharing_level,
      locations: extractHierarchyStrings(initialProfileData.rent_preferences.locations), // Convert object to array
    }
  }

  return profileUpdateFormStateInitial
}

_____________________________

shallwe_frontend/src/mocks/browser.ts:

import { setupWorker } from 'msw/browser'
import { handlers } from './handlers'

export const worker = setupWorker(...handlers)

_____________________________

shallwe_frontend/src/mocks/handlers.ts:

import { http, HttpResponse } from 'msw'
import { getDocumentCookie } from '@/lib/common/cookie'


// --- Mock data structures ---
const mockUserProfile = {
  profile: {
    is_hidden: true,
    name: "–ñ–∞–Ω–Ω–∞",
    photo_w768: "/media/profile-photos/valid-format.webp",
    photo_w540: "/media/CACHE/images/profile-photos/valid-format/48b30af8f559237f115cb97f6b29d6c3.webp",
    photo_w192: "/media/CACHE/images/profile-photos/valid-format/ffdfdd5001b678517d6f10c82650581a.webp",
    photo_w64: "/media/CACHE/images/profile-photos/valid-format/181eccfd1992d4775c37070e9b98e463.webp"
  },
  rent_preferences: {
    min_budget: 2,
    max_budget: 2,
    min_rent_duration_level: 2,
    max_rent_duration_level: 2,
    room_sharing_level: 2,
    locations: {
      regions: [
        {
          hierarchy: "UA09",
          region_name: "–í—ñ–Ω–Ω–∏—Ü—å–∫–∞"
        }
      ],
      cities: [
        {
          hierarchy: "UA0199999001",
          region_name: "–ö–∏—ó–≤—Å—å–∫–∞",
          ppl_name: "–ö–∏—ó–≤",
          districts: [
            {
              hierarchy: "UA019999900101",
              district_name: "–ü–æ–¥—ñ–ª—å—Å—å–∫–∏–π"
            },
            {
              hierarchy: "UA019999900102",
              district_name: "–®–≤–µ–π—Ü–∞—Ä—Å—å–∫–∏–π"
            }
          ]
        },
        {
          hierarchy: "UA0299999001",
          region_name: "–û–¥–µ—Å—å–∫–∞",
          ppl_name: "–ö–∏—Å–µ–ª—å",
          districts: []
        }
      ],
      other_ppls: [
        {
          hierarchy: "UA0499999001",
          region_name: "–Ü–≤–∞–Ω–æ-–§—Ä–∞–Ω–∫—ñ–≤—Å—å–∫–∞",
          subregion_name: "–í–∏–Ω–æ–≥—Ä–∞–¥–Ω–∏–π",
          ppl_name: "–ö–∏—à–º–∏—à"
        }
      ]
    }
  },
  about: {
    birth_date: "2002-02-20",
    gender: 2,
    is_couple: true,
    has_children: true,
    occupation_type: 2,
    drinking_level: 2,
    smoking_level: 2,
    smokes_iqos: true,
    smokes_vape: true,
    smokes_tobacco: false,
    smokes_cigs: false,
    neighbourliness_level: 2,
    guests_level: 2,
    parties_level: 2,
    bedtime_level: 2,
    neatness_level: 2,
    has_cats: true,
    has_dogs: true,
    has_reptiles: true,
    has_birds: true,
    other_animals: [
      "–¥—Ä–∞–∫–æ–Ω",
      "—Ä–∞–≤–ª–∏–∫"
    ],
    interests: [
      "–∫—ñ–Ω–æ",
      "–ø–ª–∞–≤–∞–Ω–Ω—è"
    ],
    bio: "–•–ê–õ–õ–û! –ù–∞–ø–∏—Å–∞–≤ —Ç—É—Ç –≤–∞–º —Ç—Ä–æ—Ö–∏ –ø—Ä–æ —Å–≤–æ—ó –∑–∞—Ö–æ–ø–ª–µ–Ω–Ω—è :)))\n–ì–æ—Ç–æ–≤–∏–π –¥–æ –Ω–æ–≤–∏—Ö –∑—É—Å—Ç—Ä—ñ—á–µ–π!"
  }
}


const mockLocations = {
  regions: [
    {
      hierarchy: "UA01",
      region_name: "–ö–∏—ó–≤—Å—å–∫–∞"
    }
  ],
  cities: [
    { 
      hierarchy: "UA0199999001", 
      region_name: "–ö–∏—ó–≤—Å—å–∫–∞", 
      ppl_name: "–ö–∏—ó–≤", 
      districts: [
        {
          hierarchy: "UA019999900101",
          district_name: "–ü–æ–¥—ñ–ª—å—Å—å–∫–∏–π"
        },
        {
          hierarchy: "UA019999900102",
          district_name: "–®–µ–≤—á–µ–Ω–∫—ñ–≤—Å—å–∫–∏–π"
        }
      ]
    },
    {
      hierarchy: "UA0299999001",
      region_name: "–û–¥–µ—Å—å–∫–∞",
      ppl_name: "–û–¥–µ—Å–∞",
      districts: []
    },
  ],
  other_ppls: [
    {
      hierarchy: "UA0499999001",
      region_name: "–Ü–≤–∞–Ω–æ-–§—Ä–∞–Ω–∫—ñ–≤—Å—å–∫–∞",
      subregion_name: "–í–∏–Ω–æ–≥—Ä–∞–¥–Ω–∏–π",
      ppl_name: "–ö–∏—à–º–∏—à"
    }
  ]
}


// --- Mock API handlers ---
const mockApiUrl = '*/api/rest'


const simulateDelay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms))


const getMultipartRepresentation = (formData: FormData): Record<string, any> => {
  const repr: Record<string, any> = {}

  for (const [key, value] of formData.entries()) {
    if (repr[key] !== undefined) {
      // Already exists -> convert to array (if not yet)
      if (!Array.isArray(repr[key])) {
        repr[key] = [repr[key]]
      }
      repr[key].push(value)
    }
    else {
      // First occurrence
      repr[key] = value
    }
  }

  return repr
}


export const handlers = [

  // --- Auth ---
  // Login
  http.post(`${mockApiUrl}/auth/login/google/`, async ({ request }) => {
    const body = await request.json()
    const loginBody = body as { code?: string }

    console.log("Mock: Received login request with code (simulated):", loginBody.code)

    await simulateDelay(500)
    return HttpResponse.json({ key: "mock_session_key" }, {
      status: 200,
    })
  }),


  // Logout
  http.post(`${mockApiUrl}/auth/logout/`, async () => {
    console.log("Mock: Received logout request")

    await simulateDelay(300)
    return new HttpResponse(null, { status: 200 })
  }),


  // --- Access ---
  // Profile status
  http.get(`${mockApiUrl}/access/profile-status/`, async ({ cookies }) => {
    console.log("Mock: Received profile status request. Cookies:", cookies)

    await simulateDelay(200)
    return new HttpResponse(null, { status: 404 })
  }),


  // --- Profile ---
  // Read profile
  http.get(`${mockApiUrl}/profile/me/`, async () => {
    console.log("Mock: Received get profile request")

    await simulateDelay(400)
    return HttpResponse.json(mockUserProfile)
  }),


  // Create profile
  http.post(`${mockApiUrl}/profile/me/`, async ({ request }) => {
    console.log("Mock: Received create profile request")

    const formData = await request.formData()
    const formDataRepr = getMultipartRepresentation(formData)
    console.log('Mock: Received profile data:', formDataRepr)

    await simulateDelay(800)
    return new HttpResponse(null, { status: 201 })
  }),


  // Update profile
  http.patch(`${mockApiUrl}/profile/me/`, async ({ request }) => {
    console.log("Mock: Received update profile request")

    const forceApiErrorCookieName = 'shallwe_test_profile_update_force_api_error'
    const forceApiErrorValue = getDocumentCookie(forceApiErrorCookieName)
    console.log(`Mock: cookie '${forceApiErrorCookieName}' is '${forceApiErrorValue}'`)

    if (forceApiErrorValue === 'true') {
      console.log(`Mock: Forcing API Error as per '${forceApiErrorCookieName}' cookie.`);
      return HttpResponse.json(
        {
          error: {
            non_field_errors: ["Forced QA Error (via cookie): Profile update failed due to server issue."],
          }
        },
        { status: 400 }
      )
    }

    const formData = await request.formData()
    const formDataRepr = getMultipartRepresentation(formData)
    console.log('Mock: Received profile data:', formDataRepr)

    await simulateDelay(600)
    return HttpResponse.json(mockUserProfile) // Return "updated" profile data
  }),


  // Update profile visibility
  http.patch(`${mockApiUrl}/profile/visibility/`, async ({ request }) => {
    console.log("Mock: Received update profile visibility request")

    const body = await request.json()
    console.log("Mock: Received visibility data:", body)

    await simulateDelay(300)
    return new HttpResponse(null, { status: 200 })
  }),


  // --- Locations ---
  // Search locations
  http.get(`${mockApiUrl}/locations/search/`, async ({ request }) => {
    console.log("Mock: Received location search request")

    const url = new URL(request.url)
    const query = url.searchParams.get('query')

    console.log("Mock: Search query:", query)

    await simulateDelay(300)

    if (query && query.length >= 2) {
      return HttpResponse.json(mockLocations)
    }
    else {
      return HttpResponse.json({ error: "Query too short" }, { status: 400 })
    }
  }),


  // --- Facecheck ---
  // Check photo for face
  http.post(`${mockApiUrl}/photo/facecheck/`, async ({ request }) => {
    console.log("Mock: Received facecheck request")

    const formData = await request.formData()
    const imageFile = formData.get('image') as File | null

    console.log("Mock: Received image file:", imageFile?.name)

    await simulateDelay(500)
    return HttpResponse.json({ success: true })
  }),


  // --- User ---
  // Delete user
  http.delete(`${mockApiUrl}/auth/user/`, async () => {
    console.log("Mock: Received delete user request")

    await simulateDelay(600)
    return new HttpResponse(null, { status: 204 })
  }),
]

_____________________________

shallwe_frontend/src/middleware.ts:

/*
Since frontend has a specified step-by-step flow, middleware controls that user only accesses the pages they are
meant to access based on that logic. The frontend should hit middleware per each page load to assure this.
*/

import { NextRequest, NextResponse } from 'next/server'
import { env } from '@/config/env'
import { getProfileStatus } from '@/lib/shallwe/access/api/calls'


const apiBaseUrl = env.NEXT_PUBLIC_SHALLWE_API_BASE_URL_EXTERNAL
const isMiddlewareSkipped = env.NEXT_PUBLIC_SHALLWE_SKIP_MIDDLEWARE

const MAX_RETRIES = 3
const ATTEMPT_TIMEOUT_MS = 2500
const BACKOFF_MS = 200


const withTimeout = <T,>(p: Promise<T>, ms: number) =>
  Promise.race<T>([
    p,
    new Promise<T>((_, rej) => setTimeout(() => rej(new Error('timeout')), ms)),
  ])

const sleep = (ms: number) => new Promise((r) => setTimeout(r, ms))


async function tryFetchProfileStatus(cookie?: string): Promise<number> {
  let lastErr: unknown
  for (let i = 0; i < MAX_RETRIES; i++) {
    try {
      const r = await withTimeout(getProfileStatus(cookie), ATTEMPT_TIMEOUT_MS)
      return r.status as number
    } catch (e) {
      lastErr = e
      if (i < MAX_RETRIES - 1) await sleep(BACKOFF_MS)
    }
  }
  throw lastErr ?? new Error('profile-status failed')
}


const redirectRules: Record<number, Record<string, string | null>> = {
  // Where to redirect based on access code and current page
  403: {
    '/': null,
    default: '/',
  },
  404: {
    '/setup': null,
    default: '/setup',
  },
  200: {
    '/': '/settings',
    '/setup': '/settings',
    default: null,
  },
}


const redirectAdmin = (request: NextRequest): NextResponse => {
    const newUrl = request.nextUrl.clone()
    const backendUrl = new URL(apiBaseUrl)

    newUrl.protocol = backendUrl.protocol
    newUrl.hostname = backendUrl.hostname
    newUrl.port = backendUrl.port
    newUrl.searchParams.delete('next')

    console.log(`Redirecting admin request from ${request.nextUrl.href} to ${newUrl.href}`)
    return NextResponse.redirect(newUrl)
}


const redirectPages = async (request: NextRequest): Promise<NextResponse> => {
  try {
    const cookie = request.headers.get('cookie')
    const profileStatus = await tryFetchProfileStatus(cookie || undefined)

    console.log(`Profile status check API call returned: ${profileStatus}`)

    const statusRedirectRules = redirectRules[profileStatus]
    if (!statusRedirectRules) {
      console.error(`Unexpected status ${profileStatus} from profile-status API`)
      return NextResponse.redirect(new URL('/', request.url))
    }

    const supposedRedirect = statusRedirectRules[request.nextUrl.pathname]
    const redirectTo = (
      supposedRedirect === undefined ?
      statusRedirectRules.default : supposedRedirect
    ) ?? null

    if (redirectTo) {
      return NextResponse.redirect(new URL(redirectTo, request.url))
    }

    return NextResponse.next()  // No redirect needed, allow to proceed
  }
  catch (error) {
    console.error(`Error calling profile-status API in middleware:`, error)
    // If not on landing, go to landing; otherwise allow landing to render.
    if (request.nextUrl.pathname !== '/') {
      return NextResponse.redirect(new URL('/', request.url))
    }
    return NextResponse.next()
  }
}


export async function middleware(request: NextRequest): Promise<NextResponse> {
  const { pathname } = request.nextUrl

  if (
    pathname === '/' ||
    pathname === '/setup' ||
    pathname === '/settings' ||
    pathname.startsWith('/admin')
  ) {
    
    if (isMiddlewareSkipped) {
      console.log('Middleware is skipped based on environment variable.')
      return NextResponse.next()
    }

    if (pathname.startsWith('/admin')) return redirectAdmin(request)
    else return redirectPages(request)
  }
  
  return NextResponse.next()
}

_____________________________

shallwe_frontend/.gitignore:

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*
!.env.example

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

_____________________________

shallwe_frontend/eslint.config.mjs:

import { dirname } from "path"
import { fileURLToPath } from "url"
import { FlatCompat } from "@eslint/eslintrc"


const __filename = fileURLToPath(import.meta.url)
const __dirname = dirname(__filename)


const compat = new FlatCompat({
  baseDirectory: __dirname,
})


const eslintConfig = [
  ...compat.extends("next/core-web-vitals", "next/typescript"),
  {
    ignores: [
      "node_modules/**",
      ".next/**",
      "out/**",
      "build/**",
      "next-env.d.ts",
    ],
  },
]


export default eslintConfig

_____________________________

shallwe_frontend/next.config.ts:

import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
};

export default nextConfig;

_____________________________

shallwe_frontend/package.json:

{
  "name": "shallwe_frontend",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "next build --turbopack",
    "start": "next start",
    "lint": "eslint"
  },
  "dependencies": {
    "date-fns": "^4.1.0",
    "msw": "^2.11.3",
    "next": "15.5.4",
    "react": "19.1.0",
    "react-dom": "19.1.0",
    "react-easy-crop": "^5.5.3",
    "react-tag-input-component": "^2.0.2",
    "zod": "^4.1.12"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@tailwindcss/postcss": "^4",
    "@types/node": "^20.19.19",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "eslint": "^9",
    "eslint-config-next": "15.5.4",
    "tailwindcss": "^4",
    "typescript": "^5"
  }
}

_____________________________

shallwe_frontend/postcss.config.mjs:

const config = {
  plugins: ["@tailwindcss/postcss"],
};

export default config;

_____________________________

shallwe_frontend/tailwind.config.ts:

import type { Config } from 'tailwindcss'


const config: Config = {
  content: [
    './src/pages/**/*.{js,ts,jsx,tsx,mdx}',
    './src/components/**/*.{js,ts,jsx,tsx,mdx}',
    './src/app/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  plugins: [],
}

export default config

_____________________________

shallwe_frontend/tsconfig.json:

{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}

_____________________________

tools/compose_project_snapshot.cjs:

#!/usr/bin/env node
// Compose a single snapshot file of the project (respects .gitignore files, including nested ones)


const fs = require('fs').promises;
const path = require('path');
const Ignore = require('ignore');

const MAX_FILE_BYTES = 1024 * 1024; // 1 MB - still used as a fallback for very large text files

// Extensions to skip based on file extension (lowercase, include leading dot)
const SKIP_EXTENSIONS = new Set([
  // images
  '.png', '.jpg', '.jpeg', '.webp', '.gif', '.bmp', '.svg', '.ico', '.tif', '.tiff',
  // videos / audio
  '.mp4', '.mov', '.avi', '.mkv', '.webm', '.mp3', '.wav', '.ogg', '.flac', '.m4a',
  // fonts
  '.woff', '.woff2', '.ttf', '.otf', '.eot',
  // archives / packages
  '.zip', '.tar', '.gz', '.tgz', '.7z', '.rar', '.jar',
  // documents / binaries / others
  '.pdf', '.exe', '.dll', '.bin', '.class', '.so', '.dmg', '.iso'
]);

// Basenames to always skip (common lockfiles - package.json is enough for package metadata)
const SKIP_BASENAMES = new Set([
  'package-lock.json',
  'yarn.lock',
  'pnpm-lock.yaml',
  'npm-shrinkwrap.json'
]);

async function collectGitignores(root) {
  const ig = Ignore();
  ig.add('.git');
  const stack = [root];
  while (stack.length) {
    const dir = stack.pop();
    let entries;
    try {
      entries = await fs.readdir(dir, { withFileTypes: true });
    } catch {
      continue;
    }
    for (const e of entries) {
      const full = path.join(dir, e.name);
      if (e.isDirectory()) {
        stack.push(full);
      } else if (e.isFile() && e.name === '.gitignore') {
        const relDir = path.relative(root, dir).replace(/\\/g, '/');
        const raw = await fs.readFile(full, 'utf8');
        const lines = raw.split(/\r?\n/).map(l => l.trim()).filter(l => l && !l.startsWith('#'));
        for (let p of lines) {
          const neg = p.startsWith('!');
          if (neg) p = p.slice(1);
          let transformed;
          if (relDir === '') {
            transformed = (neg ? '!' : '') + p;
          } else {
            if (p.startsWith('/')) {
              transformed = (neg ? '!' : '') + path.posix.join(relDir, p.slice(1));
            } else {
              transformed = (neg ? '!' : '') + path.posix.join(relDir, p);
            }
          }
          ig.add(transformed);
        }
      }
    }
  }
  return ig;
}

async function buildTree(root, ig) {
  async function readDir(dir, relPrefix = '') {
    let entries;
    try {
      entries = await fs.readdir(dir, { withFileTypes: true });
    } catch {
      return [];
    }
    entries.sort((a, b) => {
      if (a.isDirectory() && !b.isDirectory()) return -1;
      if (!a.isDirectory() && b.isDirectory()) return 1;
      return a.name.localeCompare(b.name);
    });
    const children = [];
    for (const e of entries) {
      const relPath = path.posix.join(relPrefix, e.name);
      if (ig.ignores(relPath)) continue;
      const full = path.join(dir, e.name);
      if (e.isDirectory()) {
        children.push({ type: 'dir', name: e.name, full, rel: relPath });
      } else if (e.isFile()) {
        children.push({ type: 'file', name: e.name, full, rel: relPath });
      }
    }
    return children;
  }

  const fileList = [];
  async function recurse(dir, relPrefix = '', prefixMarkers = []) {
    const children = await readDir(dir, relPrefix);
    for (let i = 0; i < children.length; i++) {
      const c = children[i];
      const isLast = i === children.length - 1;
      const segs = [];
      // prefixMarkers contains booleans indicating "hasMoreSiblings" for each ancestor level.
      // If hasMoreSiblings is true => show vertical bar ('|  '), otherwise show spaces ('    ').
      for (let j = 0; j < prefixMarkers.length; j++) {
        segs.push(prefixMarkers[j] ? '|   ' : '    ');
      }
      segs.push(isLast ? '`-- ' : '|-- ');
      const line = segs.join('') + c.name;
      treeLines.push(line);
      if (c.type === 'dir') {
        // pass whether this level has more siblings (i.e. not last) to children
        await recurse(c.full, c.rel, prefixMarkers.concat(!isLast));
      } else {
        fileList.push({ full: c.full, rel: c.rel });
      }
    }
  }

  const treeLines = [];
  const rootName = path.basename(root);
  treeLines.push(`${rootName}/`);
  await recurse(root, '', []);
  return { treeLines, fileList };
}

function isBinaryBuffer(buf) {
  return buf.includes(0);
}

async function main() {
  const projectRoot = process.cwd();
  const ig = await collectGitignores(projectRoot);
  
  // ensure common dirs / files are ignored
  ig.add('node_modules');
  ig.add('.next');
  ig.add('dist');
  ig.add('build');

  // also ignore lockfiles explicitly (we only want package.json)
  ig.add('package-lock.json');
  ig.add('yarn.lock');
  ig.add('pnpm-lock.yaml');
  ig.add('npm-shrinkwrap.json');

  const { treeLines, fileList } = await buildTree(projectRoot, ig);

  const out = [];

  out.push('=================');
  out.push('PROJECT STRUCTURE:');
  out.push('=================');
  out.push('');
  for (const l of treeLines) out.push(l);
  out.push('');
  out.push('=================');
  out.push('CODE/TEXT CONTENT OF THE PROJECT');
  out.push('=================');
  out.push('');

  for (const f of fileList) {
    out.push(f.rel + ':');
    out.push('');

    // skip by basename (lockfiles) first
    const base = path.basename(f.rel);
    if (SKIP_BASENAMES.has(base)) {
      out.push(`[skipped: ${base} (lockfile / intentionally excluded)]`);
      out.push('_____________________________');
      out.push('');
      continue;
    }

    // skip by extension
    const ext = path.extname(f.rel).toLowerCase();
    if (SKIP_EXTENSIONS.has(ext)) {
      out.push(`[skipped: ${ext || 'no-ext'} file (extension-based skip)]`);
      out.push('_____________________________');
      out.push('');
      continue;
    }

    let stat;
    try {
      stat = await fs.stat(f.full);
    } catch (e) {
      out.push('[error reading file]');
      out.push('_____________________________');
      out.push('');
      continue;
    }

    if (stat.size > MAX_FILE_BYTES) {
      out.push(`[skipped: file too large (${stat.size} bytes)]`);
      out.push('_____________________________');
      out.push('');
      continue;
    }

    let buf;
    try {
      buf = await fs.readFile(f.full);
    } catch (e) {
      out.push('[error reading file]');
      out.push('_____________________________');
      out.push('');
      continue;
    }

    if (isBinaryBuffer(buf)) {
      out.push(`[binary file skipped, ${stat.size} bytes]`);
      out.push('_____________________________');
      out.push('');
      continue;
    }

    const txt = buf.toString('utf8');
    out.push(txt);
    out.push('_____________________________');
    out.push('');
  }

  process.stdout.write(out.join('\n'));
}

main().catch(err => {
  console.error('Error:', err);
  process.exit(1);
});

_____________________________

.env.example:

#          Mode
NEXT_PUBLIC_SHALLWE_ENV_MODE=                   # DEV, QA, STAGE or PROD
#          Oauth
NEXT_PUBLIC_SHALLWE_OAUTH_CLIENT_ID=            # OAuth Client ID (get: Google Console)
NEXT_PUBLIC_SHALLWE_OAUTH_REDIRECT_URI=         # Public landing address (http(s):// + IP:port (locally) or domain address)
#          Network
NEXT_PUBLIC_SHALLWE_API_BASE_URL_EXTERNAL=      # Public backend address (http(s):// + IP:port or domain address)
NEXT_PUBLIC_SHALLWE_API_BASE_URL_INTERNAL=      # Local backend address (local URL:port if co-hosted, otherwise same as external)
#          Middleware
NEXT_PUBLIC_SHALLWE_SKIP_MIDDLEWARE=            # Whether to skip routing rules for test (true/false)
NEXT_PUBLIC_SHALLWE_MOCK_API=                   # Whether to mock api responses for test (true/false)
NEXT_PUBLIC_SHALLWE_MIDDLEWARE_COOKIES_SECURE=  # Whether to use secure cookies for middleware purposes (true/false)

_____________________________

.gitignore:

.env*
!.env.example
.idea
_____________________________

LICENSE:

SPDX-License-Identifier: LicenseRef-Evaluation-Only

Evaluation License (Read-Only, Source-Available)

Copyright (c) 2023‚Äì2025, Shallwe project author(s). All rights reserved.

1. Grant of Limited License
   Subject to the terms below, the Licensor grants you a limited, revocable, non-exclusive, non-transferable license to:
   - clone and locally view the source code;
   - build and run the software locally or in your personal or private cloud account solely for internal evaluation and recruiting/technical review (non-commercial, non-production).

2. Restrictions
   You shall NOT:
   - use the software in production or any commercial context;
   - make the software or any running instance publicly available as a service (beyond private evaluation access by you or your immediate team for hiring/technical review);
   - modify, adapt, translate, or create derivative works from the software, except as strictly necessary to configure and run your private evaluation;
   - distribute, sublicense, sell, lease, rent, host for third parties, or otherwise make the software or any derivative available to third parties;
   - publish, copy, or disclose any portion of the software beyond what is necessary for the evaluation described above;
   - remove or obscure any copyright, trademark, or proprietary notices;
   - attempt to circumvent technical limitations or reverse engineer except to the extent permitted by applicable law.

3. Ownership
   The software is licensed, not sold. The Licensor retains all right, title, and interest in and to the software and all copies thereof.

4. Term and Termination
   This license is effective until terminated. It automatically terminates if you breach any term. Upon termination, you must cease all use, delete all copies, and certify deletion upon request. The Licensor may revoke this license at any time at its discretion.

5. No Warranty
   THE SOFTWARE IS PROVIDED ‚ÄúAS IS‚Äù AND ‚ÄúAS AVAILABLE,‚Äù WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE, AND NON‚ÄëINFRINGEMENT. YOU ASSUME ALL RISKS ARISING OUT OF USE OR PERFORMANCE.

6. Limitation of Liability
   TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL THE LICENSOR OR CONTRIBUTORS BE LIABLE FOR ANY INDIRECT, INCIDENTAL, SPECIAL, CONSEQUENTIAL, EXEMPLARY, OR PUNITIVE DAMAGES, OR ANY LOSS OF PROFITS, REVENUE, DATA, OR GOODWILL, ARISING OUT OF OR IN CONNECTION WITH THIS LICENSE OR THE USE OR INABILITY TO USE THE SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. IN NO EVENT SHALL THE TOTAL LIABILITY EXCEED ONE HUNDRED (100) USD.

7. Feedback
   Any feedback, ideas, or suggestions you provide may be used by the Licensor without restriction or obligation of any kind.

8. Entire Agreement
   This License constitutes the entire agreement between you and the Licensor with respect to the software‚Äôs evaluation use and supersedes all prior or contemporaneous communications. If any provision is held unenforceable, the remainder shall remain in full force.

9. Contact for Alternative Terms
   For commercial, production, educational, or broader rights, please contact the Licensor to negotiate a separate agreement.

END OF TERMS

_____________________________

project_snapshot.txt:


_____________________________

README.md:

# Shallwe Frontend (demo)

> ‚ö†Ô∏è Work in Progress. This repo is one part of a bigger codebase. The frontend was built mainly to make the demo *clickable* and understandable without digging into backend code. Some parts were vibe-coded (mostly CSS and Tailwind) to save time ‚Äî this wasn‚Äôt meant as a design project.

> Usage: Evaluation-Only (see LICENSE)

---

üìú Background

This is the demo UI for **Shallwe**, a Ukrainian flatmate-matching platform prototype focused on compatibility rather than listings. The backend is Django REST (see separate repo); this is the **Next.js app** that visualizes it.

- Status: working mock demo; still WIP in visuals and minor refactors.
- Purpose: show how the app flows and how the data validation works, with real routing and mocked API calls for local usage.

---

‚úÖ What‚Äôs implemented (and works)

- **Auth & Middleware Routing** ‚Äî real logic that redirects users depending on access/profile state; runs against `/access` endpoints (mocked locally, real later).
- **Landing page** ‚Äî minimal intro and entry point for auth.
- **Setup flow** ‚Äî multi-step form for initial profile creation.
- **Profile view & edit** ‚Äî full edit mode with field-level validation, typed state, and update handling.
- **Photo cropper** ‚Äî interactive crop and preview with fallback image handling and mock AI moderation call.
- **Location selector** ‚Äî search and select based on Ukraine‚Äôs KATOTTG dataset:
  - regions, cities, and other populated places are distinct;
  - city districts are nested under their city entries.
- **Form validation** ‚Äî mirrors backend logic (validators and type guards).
- **MSW mocks** ‚Äî mock service worker simulating backend responses for local/demo mode.
- **Typed API layer** ‚Äî each feature module (auth, profile, locations, photo, etc.) has its own calls and schemas.

Not included: search, contacts, and chats (were part of future roadmap).

---

üèó Architecture (short)

- Framework: **Next.js 14 (App Router)** + **TypeScript** + **TailwindCSS**.
- Data layer: under `src/lib/shallwe/*`, mirrors backend API schemas and calls.
- Validation & form state: separated collectors, validators, and states under each module (profile, photo, rent preferences, etc.).
- Middleware: real redirect logic tied to auth/profile state, identical to how backend would respond.
- Mocking: **MSW (Mock Service Worker)** runs in the browser for local API simulation.
- Render logic: simple component hierarchy ‚Äî landing ‚Üí setup ‚Üí profile (view/edit).
- Design: intentionally functional, not styled for production polish.

---

üîå Backend/API reference
- [SwaggerHub Spec](https://app.swaggerhub.com/apis/S3MCHANNEL/shallwe-api/0.6.1)

Slighly outdated backend version in API spec - though, no fields or validation rules have changed since

---

ü¶Ø How to run locally (standalone)

1. **Install dependencies**
   ```bash
   npm install
   ```

2. **Copy environment example**
   ```bash
   cp .env.example .env
   ```
   Read the comments to provide correct values

3. **Run the app (mock mode)**
   ```bash
   npm run dev
   ```
   The MSW worker starts automatically and intercepts API calls.

4. **Open the demo**
   ```
   http://localhost:3000
   ```
   You can go through landing ‚Üí setup ‚Üí profile ‚Üí settings/edit and explore how validation and routing behave.

---

üåê Deployment

- Planned: **Vercel (free tier)** for the public demo.
- Current: local-only with MSW mocks.
- Once backend stage API (AWS) is live, switching to real mode is a single env variable change.

---

ü§ï Testing

- Manual QA via local mock interactions (form filling, validation, redirects, cropping, etc.).
- No automated tests yet (planned for validators and mocks).

---

üõ† Tech note (short)

- Stack: **Next.js**, **TypeScript**, **TailwindCSS**, **MSW**.
- Approach: keep frontend light, predictable, and typed; skip unnecessary libraries.
- UI/UX: minimal, purely functional; CSS work left for later refactor.
- Linting: ESLint & Prettier enabled.

---

üìä Plans and constraints

- **Plans:**
  - Refactor component layout and shared form states.
  - Integrate live backend once available.
  - Add simple landing/about screens.
  - Deploy to Vercel.

- **Constraints:**
  - Mock-only mode for now.
  - No design system or CI yet.
  - Focused on clarity and correctness, not styling.

---

üîê License and usage

This repository is provided for **evaluation purposes only (read-only)**.

All rights reserved.

- You may: clone, read, run locally, and evaluate as part of recruiting/technical review.
- You may not: modify, distribute, or use the code in any product or derivative work.

Copyright ¬© the project author.

---

üôã‚Äç‚ôÇÔ∏è Contact

Feel free to reach out for a quick walkthrough or architecture chat.

LinkedIn: [Serhii Soldatov](https://www.linkedin.com/in/serhii-soldatov)

_____________________________
